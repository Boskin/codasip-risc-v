/*
 * SemExtrConstants.h
 *
 *  Created on: Jan 22, 2014
 *      Author: ihusar
 */

#ifndef SEMEXTRCONSTANTS_H_
#define SEMEXTRCONSTANTS_H_



//must not collide with names generated by llvm (the underscore should assure that)
//used in getNewAuxVariableName
const std::string AUX_VAR_PREFIX("%cond_aux");
//const char* const UNDEF_OP_NAME = "undef";
const std::string UNNAMED_PREFIX("unnamed");

const char* const CODASIP_USER_FUNCTION_PREFIX = "codasip_user_";


// commonly used function names
const char* const SE_COMPILER_BUILTIN = "codasip_compiler_builtin";
const char* const SE_COMPILER_PRIORITY = "codasip_compiler_priority";
const char* const SE_COMPILER_UNUSED = "codasip_compiler_unused";
const char* const SE_COMPILER_UNDEFINED = "codasip_compiler_undefined";
const char* const SE_COMPILER_LATENCY = "codasip_compiler_latency";
const char* const SE_COMPILER_SCHEDULE_CLASS = "codasip_compiler_schedule_class";

const char* const SE_COMPILER_PREDICATE_TRUE = "codasip_compiler_predicate_true";
const char* const SE_COMPILER_PREDICATE_FALSE = "codasip_compiler_predicate_false";

const char* const SE_COMPILER_HW_LOOP = "codasip_compiler_hw_loop";

const char* const SE_COMPILER_FLAG_CMP_ = "codasip_compiler_flag_cmp_";

const char* const SE_STORE_EXIT_CODE = "codasip_store_exit_code";

const char* const SE__ASSERT_FUNCTION = "_codasip_assert_function";
const char* const SE__ERROR_FUNCTION = "_codasip_error_function";
const char* const SE__FATAL_FUNCTION = "_codasip_fatal_function";
const char* const SE__WARNING_FUNCTION = "_codasip_warning_function";

const char* const SE_NOP = "codasip_nop";
const char* const SE_HALT = "codasip_halt";
const char* const SE_SYSCALL = "codasip_syscall";

const char* const SE_BITCAST = "codasip_bitcast";

const char* const SE_PREP_DEFINE = "codasip_preprocessor_define";

//this array contains a list of functions that are ignored when extracting semantics
const size_t IGNORED_FUNCS_SIZE = 15;
const std::string IGNORED_FUNCS[IGNORED_FUNCS_SIZE] =
{
		"assert",
		"ASSERT",
		"printf",
		"fprintf",
		"fwrite",
		"getc",
		"getchar",
		"putc",
		"putchar",
		"puts",
		"exit",
		"codasip_print",
		"codasip_info",
		"codasip_fpu_setround",
		"codasip_fpu_getround"
};

const size_t IGNORED_GLOBALS_SIZE = 3;
const std::string IGNORED_GLOBALS[IGNORED_GLOBALS_SIZE] =
{
		"stdin",
		"stdout",
		"stderr"
};

const size_t IGNORED_INTRINS_SIZE = 7;
const Intrinsic::ID IGNORED_INTRINS[IGNORED_INTRINS_SIZE] =
{
        Intrinsic::sadd_with_overflow,
        Intrinsic::uadd_with_overflow,
        Intrinsic::ssub_with_overflow,
        Intrinsic::usub_with_overflow,
        Intrinsic::smul_with_overflow,
        Intrinsic::umul_with_overflow,
        Intrinsic::regopaddress
};

// FIXME: make this more fool-proof
// FIXME: the bitcasts must be more general
enum ECodasipBuiltinType {
	codasip_undef,
	codasip_br, //xx
	codasip_getnextpc,
	codasip_cttz,
	codasip_ctlz,
	codasip_ctlo,
	codasip_ctto,
	codasip_ctpop,
	codasip_bswap,

	codasip_carry_add,
	codasip_carry_add_c,
	codasip_borrow_sub,
	codasip_borrow_sub_c,
	codasip_overflow_add,
	codasip_overflow_add_c,
	codasip_overflow_sub,
	codasip_overflow_sub_c,
	codasip_parity_odd,

	codasip_sadd,
	codasip_sadd_occured,
	codasip_ssub,
	codasip_ssub_occured,
	codasip_usadd,
	codasip_usadd_occured,
	codasip_ussub,
	codasip_ussub_occured,
	codasip_ssat,
	codasip_ssat_occured,
	codasip_usat,
	codasip_usat_occured,
	codasip_rotl,
	codasip_rotr,
	codasip_rotl_c,
	codasip_rotr_c,

	// floats
	codasip_fcmp_oeq,
	codasip_fcmp_ogt,
	codasip_fcmp_oge,
	codasip_fcmp_olt,
	codasip_fcmp_ole,
	codasip_fcmp_one,
	codasip_fcmp_ord,

	codasip_fcmp_ueq,
	codasip_fcmp_ugt,
	codasip_fcmp_uge,
	codasip_fcmp_ult,
	codasip_fcmp_ule,
	codasip_fcmp_une,
	codasip_fcmp_uno,

	// vectors
	codasip_shufflevector,
	codasip_sext,
	codasip_zext,
	codasip_trunc,
	codasip_select,

	// special floating-point operations
	codasip_sqrt,
	codasip_powi,
	codasip_sin,
	codasip_cos,
	codasip_pow,
	codasip_exp,
	codasip_log,
	codasip_fma,
	codasip_fabs,
	codasip_floor,
	codasip_ceil,
	codasip_round,
	codasip_rint,
	codasip_ftrunc,

	codasip_is_fnegative,
	codasip_is_infinite,
	codasip_is_normalized,
	codasip_is_denormalized,
	codasip_is_fzero,
	codasip_is_qnan,
	codasip_is_snan,
	codasip_is_unsupported,
	codasip_qnan_indefinite,

	codasip_fx_mul,
	codasip_fx_div,
	codasip_fx_fptofx,
	codasip_fx_fxtofp,
	codasip_fx_itofx,
	codasip_fx_fxtoi,

	codasip_cplx_add,
	codasip_cplx_sub,
	codasip_cplx_mul,
	codasip_cplx_div,

	codasip_none //xx
};

// strings in this array must match those from builtin types
const size_t BUILTIN_NAMES_SIZE = codasip_none;
const std::string BUILTIN_NAMES[BUILTIN_NAMES_SIZE] =
{
		"undef",
		"br",
		"getcurrpc",
		"cttz",
		"ctlz",
		"ctlo",
		"ctto",
		"ctpop",
		"bswap",
		"carry_add",
		"carry_add_c",
		"borrow_sub",
		"borrow_sub_c",
		"overflow_add",
		"overflow_add_c",
		"overflow_sub",
		"overflow_sub_c",
		"parity_odd",

		"sadd",
		"sadd_occured",
		"ssub",
		"ssub_occured",
		"usadd",
		"usadd_occured",
		"ussub",
		"ussub_occured",
		"ssat",
		"ssat_occured",
		"usat",
		"usat_occured",
		"rotl",
		"rotr",
		"rotl_c",
		"rotr_c",

		// replaced in pass before printing

		// floats
		"fcmp_oeq",
		"fcmp_ogt",
		"fcmp_oge",
		"fcmp_olt",
		"fcmp_ole",
		"fcmp_one",
		"fcmp_ord",

		"fcmp_ueq",
		"fcmp_ugt",
		"fcmp_uge",
		"fcmp_ult",
		"fcmp_ule",
		"fcmp_une",
		"fcmp_uno",

		// vector
		"shufflevector",
		"sext",
		"zext",
		"trunc",
		"select",

		// ^^^^^^^^

		"sqrt",
		"powi",
		"sin",
		"cos",
		"pow",
		"exp",
		"log",
		"fma",
		"fabs",
		"floor",
		"ceil",
		"round",
		"rint",
		"ftrunc",

		"is_fnegative",
		"is_infinite",
		"is_normalized",
		"is_denormalized",
		"is_fzero",
		"is_qnan",
		"is_snan",
		"is_unsupported",
		"qnan_indefinite",

		"fx_mul",
		"fx_div",
		"fx_fptofx",
		"fx_fxtofp",
		"fx_itofx",
		"fx_fxtoi",

		"cplx_add",
		"cplx_sub",
		"cplx_mul",
		"cplx_div",
};


const size_t IGNORED_BUILTINS_SIZE = 7;
const ECodasipBuiltinType IGNORED_BUILTINS[IGNORED_BUILTINS_SIZE] =
{
        codasip_parity_odd,
        codasip_rotl,
        codasip_rotr,
        codasip_rotl_c,
        codasip_rotr_c,
        codasip_ctlo,
        codasip_ctto
};

// list of function prefixes for which must be specifier nounwind removed
// so that they are kept in the instruction semantics
// we must also specify them as readnone, so no optimization boundary is created,
// however, it must not be set as const function attribute in the libcodasip library,
// because they would be removed by the frontend during inlining
// used in RemoveNoUnwindAttr pass
// TODO: to specify readnone attribute for loads and stores may be a bit dangerous, however
//    we may probably relay on data dependencies to keep the correct order
const size_t BUILTIN_PREFIXES_TO_KEEP_SIZE = 23;
const std::string BUILTIN_PREFIXES_TO_KEEP[BUILTIN_PREFIXES_TO_KEEP_SIZE] =
{
		SE_NOP,
		SE_HALT,
		SE_SYSCALL,
		SE_COMPILER_BUILTIN,
		SE_COMPILER_PRIORITY,
		SE_COMPILER_UNUSED,
		SE_COMPILER_UNDEFINED,
		SE_COMPILER_SCHEDULE_CLASS,
		SE_COMPILER_PREDICATE_TRUE,
		SE_COMPILER_PREDICATE_FALSE,
		SE_COMPILER_HW_LOOP,
		SE_COMPILER_LATENCY,
		SE_COMPILER_FLAG_CMP_,
		SE_STORE_EXIT_CODE,
		"codasip_immread_",
		"codasip_subinstr_",
		"codasip_load_",
		"codasip_store_",
		"codasip_assert",
		SE__ASSERT_FUNCTION,
		SE__ERROR_FUNCTION,
		SE__FATAL_FUNCTION,
		SE__WARNING_FUNCTION
};

const size_t BUILTIN_PREFIXES_NOT_USERFUNC_SIZE=108;
const std::string BUILTIN_PREFIXES_NOT_USERFUNC[BUILTIN_PREFIXES_NOT_USERFUNC_SIZE] =
{
		"codasip_cttz",
		"codasip_ctlz",
		"codasip_ctlo",
		"codasip_ctto",
		"codasip_ctpop",
		"codasip_undef",

		"codasip_carry_add",
		"codasip_carry_add_c",
		"codasip_borrow_sub",
		"codasip_borrow_sub_c",
		"codasip_overflow_add",
		"codasip_overflow_add_c",
		"codasip_overflow_sub",
		"codasip_overflow_sub_c",
		"codasip_parity_odd_int",

		"codasip_sadd",
		"codasip_usadd",
		"codasip_ssub",
		"codasip_ussub",
		"codasip_ssat",
		"codasip_usat",
		"codasip_rotl_int",
		"codasip_rotr_int",
		"codasip_rotl_c_int",
		"codasip_rotr_c_int",

		SE_NOP,
		SE_HALT,
		SE_SYSCALL,

		SE_COMPILER_BUILTIN,
		SE_COMPILER_PRIORITY,
		SE_COMPILER_UNUSED,
		SE_COMPILER_UNDEFINED,
		SE_COMPILER_SCHEDULE_CLASS,
		SE_COMPILER_PREDICATE_TRUE,
		SE_COMPILER_PREDICATE_FALSE,
		SE_COMPILER_HW_LOOP,
		SE_COMPILER_LATENCY,
		SE_COMPILER_FLAG_CMP_,
		SE_STORE_EXIT_CODE,

		"codasip_reg_to_float",
		"codasip_reg_to_double",
		"codasip_float_to_reg",
		"codasip_double_to_reg",
		"codasip_immread",
		"codasip_subinstr",
		"codasip_regopindex",
		"codasip_load",
		"codasip_store",
		"codasip_assert",
		SE__ASSERT_FUNCTION,
		SE__ERROR_FUNCTION,
		SE__FATAL_FUNCTION,
		SE__WARNING_FUNCTION,
		"codasip_exit",
		
		SE_BITCAST,

		"codasip_fcmp_oeq",
		"codasip_fcmp_ogt",
		"codasip_fcmp_oge",
		"codasip_fcmp_olt",
		"codasip_fcmp_ole",
		"codasip_fcmp_one",
		"codasip_fcmp_ord",

		"codasip_fcmp_ueq",
		"codasip_fcmp_ugt",
		"codasip_fcmp_uge",
		"codasip_fcmp_ult",
		"codasip_fcmp_ule",
		"codasip_fcmp_une",
		"codasip_fcmp_uno",

		// vector
		"codasip_shufflevector",
		"codasip_sext",
		"codasip_zext",
		"codasip_trunc",
		"codasip_select",

		"codasip_sqrt",
		"codasip_powi",
		"codasip_sin",
		"codasip_cos",
		"codasip_pow",
		"codasip_exp",
		"codasip_log",
		"codasip_fma",
		"codasip_fabs",
		"codasip_floor",
		"codasip_ceil",
		"codasip_round",
		"codasip_rint",
		"codasip_ftrunc",

		"codasip_is_fnegative",
		"codasip_is_infinite",
		"codasip_is_normalized",
		"codasip_is_denormalized",
		"codasip_is_fzero",
		"codasip_is_qnan",
		"codasip_is_snan",
		"codasip_is_unsupported",
		"codasip_qnan_indefinite",

		"codasip_fx_mul",
		"codasip_fx_div",
		"codasip_fx_fptofx",
		"codasip_fx_fxtofp",
		"codasip_fx_itofx",
		"codasip_fx_fxtoi",

		"codasip_cplx_add",
		"codasip_cplx_sub",
		"codasip_cplx_mul",
		"codasip_cplx_div",

		SE_PREP_DEFINE,
};




#endif /* SEMEXTRCONSTANTS_H_ */
