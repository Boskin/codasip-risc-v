/**
 * Codasip Ltd
 * 
 * CONFIDENTIAL 
 *
 * Copyright 2014 Codasip Ltd
 * 
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of Codasip Ltd 
 * and its suppliers, if any. 
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to 
 * Codasip Ltd and are protected by trade secret and copyright law.  In addition, elements of the 
 * technical concepts may be patent pending.  
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this 
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained 
 * in Codasip license agreement under which you obtained this file.
 *
 *  \file
 *  \author Potesil Josef
 *  \date   22.10.2013
 *  \brief  Declaration of the \ref CODASIP_LOG which defines some convenient
 *          function to generate messages displayed to the end-user.
 */

#ifndef _CODASIP_LOG_H_
#define _CODASIP_LOG_H_

#include <iosfwd>
#include <string>
#include <sstream>

namespace codasip {

// forward declaration
class Location;
/**
 *  \addtogroup CODASIP_UTILITY
 *  \{
 *  \defgroup CODASIP_LOG Logging library
 *  This library should be used to generate message which should be shown to
 *  the end-user of the Codasip Framework. Defines interface to generate
 *  warnings, info, error and debug messages.
 *  \{
 */
/**
 *  \brief  Defines type of warnings generated by Codasip Framework.
 */
enum WarningType
{
    WARN_GENERAL = 0,       ///< unspecified warning
    WARN_UNUSED,            ///< unused variables, statement, resources
    WARN_NOT_INIT,          ///< uninitialized variables
    WARN_RTL_VALIDATION,    ///< warnings generated by RTL validator
    WARN_SYNTHESIS,         ///< warnings about RTL synthesis
    WARN_BACKEND,           ///< warnings from backendgen (and irparser and rlparser)
    WARN_END                ///< warning count, must be the last one!!!
};
/**
 * \brief Defines severity of logging messages.
 * \note  When modified, \ref SeverityToString has to be changed as well
 */
enum LogSeverity
{
    LOG_SEVERITY_FATAL,    ///< fatal errors that will end execution of tool
    LOG_SEVERITY_ERROR,    ///< error message, tool might partially recover from this error
    LOG_SEVERITY_WARNING,  ///< warnings
    LOG_SEVERITY_INFO,     ///< informative messages
    LOG_SEVERITY_DEBUG,    ///< debugging messages
    LOG_SEVERITY_ALL       ///< all severities, must be last
};
/**
 * \brief Defines streams that can be used for log message destination
 */
enum LogStream
{
    LOG_NO_STREAM,  ///< do not print logging messages to stream
    LOG_TO_STDOUT,  ///< print logging messages to standard output stream
    LOG_TO_STDERR   ///< print logging messages to standard error stream
};

/**
 *  \brief Defines default verbosity level
 */
const unsigned LOG_DEFAULT_VERBOSITY = 1;
/**
 *  \brief Typedef of error number
 */
typedef unsigned long SystemErrNo;
/**
 *  \namespace logging
 *  \brief  Contains implementation of logging facilities, logging
 *          messages and stores logging settings
 */
namespace logging {

/**
 * \brief Function typedef that is used for formatting message beginnings.
 * \param out Output stream used for storing formatted beginning.
 * \param severity Severity of message
 * \param warn Warning type of message, if \p severity is LOG_SEVERITY_WARNING, otherwise
          is not used
 * \param verbosity Verbosity level of message, if \p severity is LOG_SEVERITY_INFO, otherwise
 *        is not used
 * \param str String containg custom data. Default empty.
 * \param file File where to which this message belongs to. If empty, \p file and \p line is
 *        not used
 * \param line Line of \p file. If \p file is empty, \p line is not used
 * \return Formatted string that contains start of message. Rest of logging
 *         message is appended after this.
 */
typedef void (*Formatter)(std::ostream& out,
    const LogSeverity severity,
    const WarningType warn,
    const unsigned verbosity,
    const std::string& str,
    const std::string& file,
    const unsigned line);
/**
 * \brief Function typedef that is used for printing header in logging file
 * \param fp Handle to opened logging file
 */
typedef void (*LogFileHeaderWriter)(std::ostream& fp);
/**
 * \internal
 * \class LoggingMessage
 * \brief Describes single logging message. Enables creation of message content
 *        using C++ stream operator <<. Also ensures correct thread-safe printing
 *        of message to correct stream
 */
class LoggingMessage
{
public:
    /**
     * \brief Constructor
     * \param severity Severity of message
     * \param str String that will be sent to formatting function (\ref SetFormatter)
     * \param warn Warning type of message, if \p severity is LOG_SEVERITY_WARNING, otherwise
     *        is not used
     * \param verbosity Verbosity level of message, if \p severity is LOG_SEVERITY_INFO, otherwise
     *        is not used
     * \param file File where to which this message belongs to. If empty, \p file and \p line is
     *        not used
     * \param line Line of \p file. If \p file is empty, \p line is not used
     */
    LoggingMessage(LogSeverity severity,
        const std::string& str = "",
        const WarningType warn = WARN_END,
        const unsigned verbosity = 0,
        const std::string& file = "",
        const unsigned line = 0);
    /**
     * \brief Constructor. Creates logging message, that will never print any logging message.
     */
    LoggingMessage();
    /**
     * \brief Copy constructor
     */
    LoggingMessage(const LoggingMessage& lm);
    /**
     * \brief Destructor. Outputs created message into destination stream / file.
     */
    ~LoggingMessage();
    /**
     * \brief Converts this object into stream
     * \param val Value to be added into internally stored logging message stream
     * \return reference to stream used for logging message creation.
     */
    template<typename T>
    std::ostream& operator<<(T val);

private:
    /// Stream containing logging message content
    std::ostringstream m_stream;
    /// Severity of message
    LogSeverity m_severity;
    /// If output should be redirected to sink, e.g. suppressed warning
    bool m_sink;
};
/**
 *  \brief  Set global verbose level.
 *  \param  value message verbose level
 */
void SetVerbosity(const unsigned value);
/**
 *  \brief  Returns global verbose level.
 */
unsigned GetVerbosity();
/**
 *  \brief  Set given \p stream as output of logging messages of \p severity
 *  \param  severity Severity for which this output will be set. If LOG_ALL is used,
 *          given stream \p out is set for all logging levels
 *  \param  stream reference to new (standard) output stream
 */
void SetOutputStream(const LogSeverity severity, const LogStream stream);
/**
 *  \brief  Set given \p file as output of all logging messages
 *  \param  file Path for file that will be used as output for logging messages.
 *          If empty, logging to file is closed. File will be opened in
 *          appending mode, existing output won't be erased.
 *  \param  writer Function that is called when logging file is opened. Can be used
 *          to write header into logging file informing about start of new logging
 *  \return true if file was set or when \p file is empty, closed. False if
 *          set file couldn't be opened.
 */
bool SetLogingFile(const std::string& file, LogFileHeaderWriter writer = NULL);
/**
 *  \brief Set function that will format all log messages
 *  \param formatter Static C function that is used for formatting
 */
void SetFormatter(const Formatter formatter);
/**
 *  \brief  Enable warnings of given type.
 *  \param  type warning type to enable
 */
void EnableWarning(const WarningType type);
/**
 *  \brief  Disable warnings of given type.
 *  \param  type warning type to disable
 */
void DisableWarning(const WarningType type);
/**
 *  \brief  Indicates whether given warning is enabled (true) or disabled.
 *  \param  type warning type to check
 */
bool IsWarningEnabled(const WarningType type);
/**
 *  \brief  Returns string for given severity
 *  \param  severity Severity that will be converted to string
 */
const char* SeverityToString(const LogSeverity severity);

////////////////////////////////////////////////////////////////////////////////
template<typename T>
std::ostream& LoggingMessage::operator<<(T val)
{
    if(!m_sink)
    {
        m_stream << val;
    }
    return m_stream;
}

}   // codasip::logging

/**
 *  \brief  Create logging message of given severity.
 *  \param  severity Severity of logging message
 *  \param  warn Warning message type. Some warnings can be suppressed.
 *  \param  verbosity Verbosity of information message (severity has to
 *          be \ref LOG_SEVERITY_INFO)
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_SEVERITY(LogSeverity severity,
        const WarningType warn = WARN_END,
        const unsigned verbosity = 0,
        const std::string& str = "");
/**
 *  \brief  Create logging message describing debugging message.
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_DEBUG(const std::string& str = "");
/**
 *  \brief  Create informative logging message with given verbose level.
 *          Messages with insufficient verbose level will be ignored.
 *  \param  verbosity Message verbose level
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_INFO(const unsigned verbosity = LOG_DEFAULT_VERBOSITY,
    const std::string& str = "");
/**
 *  \copydoc LOG_INFO(const unsigned)
 *  \param file Source file name
 *  \param line Line number in given source file
 */
logging::LoggingMessage LOG_INFO(const std::string& file,
    const unsigned line,
    const unsigned verbosity = LOG_DEFAULT_VERBOSITY,
    const std::string& str = "");
/**
 *  \copydoc LOG_INFO(const unsigned)
 *  \param loc source file and line number
 */
logging::LoggingMessage LOG_INFO(const Location& loc,
    const unsigned verbosity = LOG_DEFAULT_VERBOSITY,
    const std::string& str = "");
/**
 *  \brief  Create logging message describing warning.
 *  \param  type Warning message type. Some warnings can be suppressed.
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_WARNING(const WarningType type = WARN_GENERAL,
    const std::string& str = "");
/**
 *  \copydoc LOG_WARNING(const WarningType)
 *  \param file Source file name
 *  \param line Line number in given source file
 */
logging::LoggingMessage LOG_WARNING(const std::string& file,
    const unsigned line,
    const WarningType type = WARN_GENERAL,
    const std::string& str = "");
/**
 *  \copydoc LOG_WARNING(const WarningType)
 *  \param loc source file and line number
 */
logging::LoggingMessage LOG_WARNING(const Location& loc,
    const WarningType type = WARN_GENERAL,
    const std::string& str = "");
/**
 *  \brief  Create logging message describing error.
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_ERROR(const std::string& str = "");
/**
 *  \copydoc LOG_ERROR()
 *  \param file Source file name
 *  \param line Line number in given source file
 */
logging::LoggingMessage LOG_ERROR(const std::string& file,
    const unsigned line,
    const std::string& str = "");
/**
 *  \copydoc LOG_ERROR()
 *  \param loc source file and line number
 */
logging::LoggingMessage LOG_ERROR(const Location& loc,
    const std::string& str = "");
/**
 *  \brief  Create logging message describing fatal error.
 *  \param  str String containing custom data, that will be sent to formatting
 *          function. Default empty.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<.
 */
logging::LoggingMessage LOG_FATAL(const std::string& str = "");
/**
 *  \brief  Create logging message that will not print anything but will behave like
 *          normal LoggingMessage.
 *  \return reference to logging message, that can be used to create message
 *          using operator <<, but will never print any output.
 */
logging::LoggingMessage LOG_NULL();
/**
 * \brief Returns last error message for last system API call
 */
std::string LOG_SYSTEM_MSG();
/**
 * \brief Shortcut for LOG_SYSTEM_MSG()
 */
#define SYSMSG codasip::LOG_SYSTEM_MSG()
/**
 * \brief Returns last error code for last system API call
 */
SystemErrNo LOG_SYSTEM_ERRNO();
/**
 * \brief Sets system last error code
 */
void SetSystemErrNo(const SystemErrNo);

/**
 * \}
 * \}
 */   // end of DOXYGEN group comment

}   // namespace codasip

#endif // _CODASIP_LOG_H_
