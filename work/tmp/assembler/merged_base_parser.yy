
/**
 * Codasip Ltd
 *
 * CONFIDENTIAL
 *
 * Copyright 2014 Codasip Ltd
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of Codasip Ltd
 * and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip Ltd and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 */

/**
 *  \brief Base of syntactic analyzer for assembly code generated by msp-gcc compiler.
 * 
 *         Instruction set information is generated automatically,
 *         this file describes mainly directives, label and constants formats.
 *
 *  \warning Nonterminals names must not begin with 'YT_',
 *           this prefix is used for generated nonterminal names.
 */

%code requires {
#include "loc_options.h"
#ifndef ASM_INSTR_TOKEN_RECOGNIZER
#include "directivehandleriface.h"
#endif
}

%{
#ifndef ASSEMBLER_BASE_SCANNER_H_
#define ASSEMBLER_BASE_SCANNER_H_

#define YYMAXDEPTH 2000000

#include "asmstdinclude.h"
#include "assembler_messages.h"
#include "tokenstructs.h"
#include "syntanalyzer.h"
#include "asmsymbol.h"
#include "codasiputils.h"
#include "directivehandleriface.h"
#include "loc_options.h"
#include "asmoptions.h"

#include "dwarflineinfo.h"
#include "dwarfframeinfo.h"

#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <string>


namespace codasip {
namespace assembler {
class Token;
class TokenList;
class TokenNode;
}
}


using namespace codasip::assembler;
using namespace std;


// Function prototypes
extern int yylex (void);
void yyerror(const char* s);


// For better error messages, load list of assembly terminals. Included file is generated by asmgenl
// from auxiliary information generated by flex from merged lexical analyzer.
#include "codasip_assembler_TokenIdInfos.h"

#endif  // ASSEMBLER_BASE_SCANNER_H_
%}


%start Start
%error-verbose

// Uncomment these two lines when bison prints error message about shift/reduce conflicts,
// assembler generator also uses this file to generate terminal symbol recognizer, for this purpose
// must be the following lines commented for assembler generation modify the file in swtlissom/src
// TODO: make this automatic? can be these settings passed in command-line arguments?
%glr-parser
//%expect-rr 9

%debug
%defines

%union
{
    std::string* text;
    codasip::assembler::Token* tok;
    codasip::assembler::TokenList* tokList;
    codasip::assembler::TokenNode* tokNode;
    int num;
    bool boolean;
    codasip::assembler::DataDirectiveType datadirtype;
    codasip::assembler::LocOptions* locOptions;
#ifndef ASM_INSTR_TOKEN_RECOGNIZER
    codasip::assembler::SectionFlags* sectionFlags;
#else
    class SectionFlags* sectionFlags;
#endif
    codasip::assembler::SymbolDefinitionOperatorEnum symbolDefinitionOperator;
}


/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------ start of user-modifiable section --------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/


// tokens - all tokens must have set fixed value,
// because we need to be sure, that generated tokens do not collide
%token <text> T_STRING  1001 "string constant"
%token <text> T_ID "identifier"
%token <text> T_MACRO_CALL "macro call"
%token <text> T_BIN_CONST "binary constant"
%token <text> T_OCT_CONST "octal constant"
%token <text> T_DEC_CONST "decimal constant"
%token <text> T_HEX_CONST "hexadecimal constant"
%token <text> T_DOUBLE_CONST "floating-point constant"
%token <text> T_MACRO_ARGUMENT_EVALUATOR "macro argument evaluator '\arg'"

%token <num> T_NEWLINE "\n"
%token T_DOT "."
%token T_DELIM ","
%token T_LABEL_DELIM ":"
%token T_OP_NEG "!"
%token T_OP_BIN_NEG "~"
%token T_OP_MULT "*"
%token T_OP_DIV "/"
%token T_OP_MOD "%"
%token T_OP_PLUS "+"
%token T_OP_MINUS "-"
%token T_OP_LSHIFT "<<"
%token T_OP_RSHIFT ">>"
%token T_OP_BIN_AND "&"
%token T_OP_BIN_XOR "^"
%token T_OP_BIN_OR "|"
%token T_PAR_LEFT "("
%token T_PAR_RIGHT ")"
%token T_AND_ASSIGN "&="
%token T_ADD_ASSIGN "+="
%token T_SUB_ASSIGN "-="
%token T_MUL_ASSIGN "*="
%token T_DIV_ASSIGN "/="
%token T_ASSIGN "="

%left T_OP_BIN_OR
%left T_OP_BIN_XOR
%left T_OP_BIN_AND
%left T_OP_LSHIFT T_OP_RSHIFT
%left T_OP_PLUS T_OP_MINUS
%left T_OP_MULT T_OP_DIV T_OP_MOD
%right UPLUS UMINUS T_OP_BIN_NEG T_OP_NEG

// directive tokens
%token T_ABS_ORG ".abs_org"
%token T_ADDRESS_SPACE ".address_space"

%token T_ALIGN ".align"
%token T_BALIGN ".balign"
%token T_BALIGNW ".balignw"
%token T_BALIGNL ".balignl"
%token T_P2ALIGN ".p2align"
%token T_P2ALIGNW ".p2alignw"
%token T_P2ALIGNL ".p2alignl"

%token T_ALTMACRO ".altmacro"
%token T_ALTMACRO_LOCAL "LOCAL"
%token T_ASCII ".ascii"
%token T_ASCIZ ".asciz"
%token T_BIT ".bit"
%token T_BUNDLE_ALIGN_END ".bundle_align_end"

%token T_BYTE ".byte"
%token T_HWORD ".hword"
%token T_INT ".int"
%token T_LONG ".long"
%token T_QUAD ".quad"
%token T_SHORT ".short"
%token T_WORD ".word"
%token T_HALF ".half"
%token T_DWORD ".dword"
%token T_2BYTE ".2byte"
%token T_4BYTE ".4byte"

%token T_CFI_STARTPROC ".cfi_startproc"
%token T_CFI_ENDPROC ".cfi_endproc"
%token T_CFI_DEF_CFA ".cfi_def_cfa"
%token T_CFI_DEF_CFA_REGISTER ".cfi_def_cfa_register"
%token T_CFI_DEF_CFA_OFFSET ".cfi_def_cfa_offset"
%token T_CFI_ADJUST_CFA_OFFSET ".cfi_adjust_cfa_offset"
%token T_CFI_OFFSET ".cfi_offset"
%token T_CFI_VAL_OFFSET ".cfi_val_offset"
%token T_CFI_REGISTER ".cfi_register"
%token T_CFI_SAME_VALUE ".cfi_same_value"
%token T_CFI_RETURN_COLUMN ".cfi_return_column"

%token T_CODASIP_RETSTRUCT_REG ".codasip_retstruct_reg"
%token T_CODASIP_RETVAL_REGS ".codasip_retval_regs"

%token T_COMM ".comm"
%token T_LCOMM ".lcomm"

%token T_DATA ".data"
%token T_TEXT ".text"
%token T_BSS ".bss"

%token T_DEBUG_OFF ".debug_off"
%token T_DEBUG_ON ".debug_on"

%token T_DOUBLE ".double"
%token T_FLOAT ".float"
%token T_SINGLE ".single"

%token T_ENDM ".endm"

%token T_EQU ".equ"
%token T_SET ".set"
%token T_EQUIV ".equiv"
%token T_EQV ".eqv"

%token T_ERR ".err"
%token T_ERROR ".error"

%token T_FILE ".file"
%token T_FILL ".fill"
%token T_GLOBAL ".global"
%token T_GLOBL ".globl"
%token T_IDENT ".ident"
%token T_INCBIN ".incbin"
%token T_LINE ".line"
%token T_LIST ".list"
%token T_LOC ".loc"
%token T_LOCAL ".local"
%token T_MACRO ".macro"
%token T_NOALTMACRO ".noaltmacro"
%token T_NOLIST ".nolist"
%token T_ORG ".org"

%token T_POPSECTION ".popsection"
%token T_PREVIOUS ".previous"
%token T_PROFILER ".profiler"
%token T_PUSHSECTION ".pushsection"
%token T_SECTION ".section"
%token T_SECTION_ADJUSTABLE ".section_adjustable"

%token T_ENDIAN_BIG ".big"
%token T_ENDIAN_LITTLE ".little"

%token T_SIZE ".size"
%token T_SKIP ".skip"
%token T_SPACE ".space"
%token T_ZERO ".zero"
%token T_SLEB128 ".sleb128"
%token T_ULEB128 ".uleb128"
%token T_TYPE ".type"
%token T_WARNING ".warning"
%token T_WEAK ".weak"


%type <text> SectionName
%type <tok> SectionTypeSpecifier CompileExpression Expression SimpleExpression DoubleConstant 
%type <tok> IntegerConstant BinaryConstant OctalConstant DecimalConstant HexadecimalConstant
%type <tok> IdOrString Identifier String MacroCallArgument
%type <tokList> CompileDoubleExpressionList CompileExpressionList ExpressionList StringList
%type <tokList> DirectiveMacroArguments MaybeMacroCallArguments MacroCallArguments
%type <tokNode> ExpressionAll ExpressionCore
%type <num> DirectiveAlignGroupType DirectiveAsciiGroupType DirectiveDataGroupType DirectiveDoubleGroupType 
%type <num> DirectiveSectionAdjustableEndianess MaybeDirectiveLocColumn MaybeDirectiveCommAlignment
%type <num> MaybeFill CompileExpressionValue IntegerConstantValue
%type <boolean> DirectiveCommGroupType DirectiveSleb128GroupType MaybeMinus
%type <datadirtype> DirectiveByteGroupType
%type <locOptions> MaybeDirectiveLocOptions
%type <sectionFlags> SectionFlags SectionType SectionFlagSpecificArguments
%type <symbolDefinitionOperator> SymbolDefinitionOperator


%%




Start : Program

//
// Starting nonterminal. In file generated from instruction set grammar is also present a rule
// that provides substitution of instruction set grammar generated strings into complete assembler
// source file language. That rule has this format: Program : Program ynt_gen_program T_NEWLINE
// NOTE: for syntax-directed editor must be this rule included in base grammar XML specification
Program
    : Program Directive T_NEWLINE
    {
        SectionHandlerUnit::SetSectionProcessed(false);
        CurrentInstructionLine::Set($3);
    }
    | Program Label
    {
        SectionHandlerUnit::SetSectionProcessed(false);
    }
    | Program MacroCall T_NEWLINE
    {
        SectionHandlerUnit::SetSectionProcessed(false);
        CurrentInstructionLine::Set($3);
    }
    | Program SymbolDefinition T_NEWLINE
    {
        SectionHandlerUnit::SetSectionProcessed(false);
        CurrentInstructionLine::Set($3);
    }
    | Program T_NEWLINE
    {
        CurrentInstructionLine::Set($2);
    }
    | Program error T_NEWLINE
    {
        // reset instruction coder (an instruction could have been parsed when error occured)
        g_SyntAnalyzer.instrCoder.ResetParsedAttrInfoSet();

        // check whether we are processing a section, if so, terminate compilation
        if (SectionHandlerUnit::IsSectionProcessed())
        {
            err::SECTION_SYNTACTIC_ERROR(LogicalFileInfo::GetLocation());
            throw AssemblerError();
        }

        CurrentInstructionLine::Set($3);
    }
    | // empty
    ;

Directive
    : DirectiveAbsOrg
    | DirectiveAddressSpace
    | DirectiveAlignGroup
    | DirectiveAltmacro
    | DirectiveAltmacroLocal
    | DirectiveAsciiGroup
    | DirectiveBit
    | DirectiveBundleAlignEnd
    | DirectiveByteGroup
    | DirectiveCfiStartproc
    | DirectiveCfiEndproc
    | DirectiveCfiDefCfa
    | DirectiveCfiDefCfaRegister
    | DirectiveCfiDefCfaOffset
    | DirectiveCfiAdjustCfaOffset
    | DirectiveCfiOffset
    | DirectiveCfiValOffset
    | DirectiveCfiRegister
    | DirectiveCfiSameValue
    | DirectiveCfiReturnColumn
    | DirectiveCodasipRetstructReg
    | DirectiveCodasipRetvalRegs
    | DirectiveCommGroup
    | DirectiveDataGroup
    | DirectiveDebugOff
    | DirectiveDebugOn
    | DirectiveDoubleGroup
    | DirectiveEndm
    | DirectiveEquGroup
    | DirectiveEquivGroup
    | DirectiveErr
    | DirectiveError
    | DirectiveFile
    | DirectiveFill
    | DirectiveGlobalGroup
    | DirectiveIdent
    | DirectiveIncbin
    | DirectiveLine
    | DirectiveList
    | DirectiveLoc
    | DirectiveLocal
    | DirectiveMacro
    | DirectiveNoaltmacro
    | DirectiveNolist
    | DirectiveOrg
    | DirectivePopsection
    | DirectivePrevious
    | DirectiveProfiler
    | DirectivePushsection
    | DirectiveSection
    | DirectiveSectionAdjustable
    | DirectiveSize
    | DirectiveSkipGroup
    | DirectiveSleb128Group
    | DirectiveType
    | DirectiveWarning
    | DirectiveWeak
    ;

DirectiveAbsOrg
    : T_ABS_ORG CompileExpression
    {
        SectionHandlerUnit::SetAbsOrg($2->ToInteger());
        delete $2;
    }
    ;

DirectiveAddressSpace
    : T_ADDRESS_SPACE CompileExpressionValue
    {
        AddressSpaceHandlerUnit::SwitchToAddressSpace($2);
    }
    ;

DirectiveAlignGroup
    : DirectiveAlignGroupType CompileExpressionValue T_DELIM CompileExpressionValue T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::GasAlign($1, $2, $4, $6);
    } 
    | DirectiveAlignGroupType CompileExpressionValue T_DELIM T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::GasAlign($1, $2, 0, $5);
    } 
    | DirectiveAlignGroupType CompileExpressionValue T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::GasAlign($1, $2, $4);
    } 
    | DirectiveAlignGroupType CompileExpressionValue
    {
        SectionHandlerUnit::GasAlign($1, $2);
    }
    ;

DirectiveAlignGroupType
    : T_ALIGN       { $$ = T_ALIGN; }
    | T_BALIGN      { $$ = T_BALIGN; }
    | T_BALIGNW     { $$ = T_BALIGNW; }
    | T_BALIGNL     { $$ = T_BALIGNL; }
    | T_P2ALIGN     { $$ = T_P2ALIGN; }
    | T_P2ALIGNW    { $$ = T_P2ALIGNW; }
    | T_P2ALIGNL    { $$ = T_P2ALIGNL; }
    ;

DirectiveAltmacro
    : T_ALTMACRO
    {
        TokenHandlerUnit::SetAlternateMacroMode(true);
    }
    ;

DirectiveAltmacroLocal
    : T_ALTMACRO_LOCAL Identifier
    {
        TokenHandlerUnit::ProcessMacroLocal($2->StrAttr());
        delete $2;
    }
    ;

DirectiveAsciiGroup
    : DirectiveAsciiGroupType StringList
    {
        // put n characters
        const bool zeroTerminated = $1 == T_ASCIZ;

        // now append each present string from list
        for (Token* token : *$2)
        {
            SectionHandlerUnit::AppendByteString(token->StrAttr(), zeroTerminated, true);
        }

        delete $2;
    }
    ;

DirectiveAsciiGroupType
    : T_ASCII   { $$ = T_ASCII; }
    | T_ASCIZ   { $$ = T_ASCIZ; }
    ;

DirectiveBit
    : T_BIT CompileExpressionValue T_DELIM ExpressionList
    {
        int bitwidth = $2;

        // now append each number from list
        for (Token* token : *$4)
        {
            SectionHandlerUnit::AppendDataBitWidth(bitwidth, token);
        }
    }
    ;

DirectiveBundleAlignEnd
    : T_BUNDLE_ALIGN_END
    {
        DirectiveHandlerUnit::BundleAlignEnd();
    }
    ;

DirectiveByteGroup
    : DirectiveByteGroupType ExpressionList
    {
        DataDirectiveType dirType = $1;

        // now append each number from list
        for (Token* token : *$2)
        {
            SectionHandlerUnit::AppendDataDirective(dirType, token);
        }

        delete $2;
    }
    ;

// returns target bitwidth
DirectiveByteGroupType
    : T_BYTE    { $$ = DATA_DIRECTIVE_BYTE; }
    | T_HWORD   { $$ = DATA_DIRECTIVE_HWORD; }
    | T_INT     { $$ = DATA_DIRECTIVE_INT; }
    | T_LONG    { $$ = DATA_DIRECTIVE_LONG; }
    | T_QUAD    { $$ = DATA_DIRECTIVE_QUAD; }
    | T_SHORT   { $$ = DATA_DIRECTIVE_SHORT; }
    | T_WORD    { $$ = DATA_DIRECTIVE_WORD; }
    | T_HALF    { $$ = DATA_DIRECTIVE_HALF; }
    | T_DWORD   { $$ = DATA_DIRECTIVE_DWORD; }
    | T_2BYTE   { $$ = DATA_DIRECTIVE_2BYTE; }
    | T_4BYTE   { $$ = DATA_DIRECTIVE_4BYTE; }
    ;

DirectiveCfiStartproc
    : T_CFI_STARTPROC
    {
        g_DwarfFrameInfo.StartProc();
    }
    ;

DirectiveCfiEndproc
    : T_CFI_ENDPROC
    {
        g_DwarfFrameInfo.EndProc();
    }
    ;

DirectiveCfiDefCfa
    : T_CFI_DEF_CFA CompileExpressionValue T_DELIM CompileExpressionValue
    {
        g_DwarfFrameInfo.DefCfa($2, $4);
    }
    ;

DirectiveCfiDefCfaRegister
    : T_CFI_DEF_CFA_REGISTER CompileExpressionValue
    {
        g_DwarfFrameInfo.DefCfaRegister($2);
    }
    ;

DirectiveCfiDefCfaOffset
    : T_CFI_DEF_CFA_OFFSET CompileExpressionValue
    {
        g_DwarfFrameInfo.DefCfaOffset($2);
    }
    ;

DirectiveCfiAdjustCfaOffset
    : T_CFI_ADJUST_CFA_OFFSET CompileExpressionValue
    {
        g_DwarfFrameInfo.AdjustCfaOffset($2);
    }
    ;

DirectiveCfiOffset
    : T_CFI_OFFSET CompileExpressionValue T_DELIM CompileExpressionValue
    {
        g_DwarfFrameInfo.Offset($2, $4);
    }
    ;

DirectiveCfiValOffset
    : T_CFI_VAL_OFFSET CompileExpressionValue T_DELIM CompileExpressionValue
    {
        g_DwarfFrameInfo.ValOffset($2, $4);
    }
    ;

DirectiveCfiRegister
    : T_CFI_REGISTER CompileExpressionValue T_DELIM CompileExpressionValue
    {
        g_DwarfFrameInfo.Register($2, $4);
    }
    ;

DirectiveCfiSameValue
    : T_CFI_SAME_VALUE CompileExpressionValue
    {
        g_DwarfFrameInfo.SameValue($2);
    }
    ;

DirectiveCfiReturnColumn
    : T_CFI_RETURN_COLUMN CompileExpressionValue
    {
        g_DwarfFrameInfo.ReturnColumn($2);
    }
    ;

DirectiveCodasipRetstructReg
    : T_CODASIP_RETSTRUCT_REG CompileExpressionValue
    {
        g_DwarfFrameInfo.CodasipRetstructReg($2);
    }
    ;

DirectiveCodasipRetvalRegs
    : T_CODASIP_RETVAL_REGS CompileExpressionList
    {
        vector<int> regs;

        // now append each number from list
        for (Token* token : *$2)
        {
            regs.push_back(token->IntAttr());
        }

        g_DwarfFrameInfo.CodasipRetvalRegs(regs);

        delete $2;
    }
    | T_CODASIP_RETVAL_REGS
    {
        // do nothing for void functions
    }
    ;

DirectiveCommGroup
    : DirectiveCommGroupType Identifier T_DELIM CompileExpressionValue MaybeDirectiveCommAlignment
    {
        // $4 is size in bytes
        SymbolHandlerUnit::DefineComm($2->StrAttr(), $1, $4, $5);
    }
    ;

// Returns if symbol should be declared as global
DirectiveCommGroupType
    : T_COMM    { $$ = true; }
    | T_LCOMM   { $$ = false; }
    ;

MaybeDirectiveCommAlignment
    : T_DELIM CompileExpressionValue    { $$ = $2; }
    |                                   { $$ = -1; }
    ;

DirectiveDataGroup
    : DirectiveDataGroupType MaybeDirectiveDataGroupFlags
    {
        int sectionType = $1;

        AsmSection::Type type;
        string name;

        if (sectionType == T_DATA)
        {
            type = AsmSection::DATA;
            name = ".data";
        }
        else if (sectionType == T_TEXT)
        {
            type = AsmSection::TEXT;
            name = ".text";
        }
        else if (sectionType == T_BSS)
        {
            type = AsmSection::BSS;
            name = ".bss";
        }
        else
        {
            THROW_ERROR() << "Nonterminal 'dir_section' failed" << std::endl;
        }

        name += g_AsmOptions.GetInputFileNameAsSectionSuffix();

        SectionHandlerUnit::CreateOrSwitchToSection(type, name);
    };

DirectiveDataGroupType
    : T_DATA
    {
        SectionHandlerUnit::SetSectionProcessed(true);
        $$ = T_DATA;
    }
    | T_TEXT
    {
        SectionHandlerUnit::SetSectionProcessed(true);
        $$ = T_TEXT;
    }
    | T_BSS
    {
        SectionHandlerUnit::SetSectionProcessed(true);
        $$ = T_BSS;
    }
    ;

MaybeDirectiveDataGroupFlags
    : T_DELIM String
    {
        wrn::IGNORE_SECTION_FLAGS(LogicalFileInfo::GetLocation(true), $2->StrAttr());
        delete $2;
    }
    |   // empty
    ;

DirectiveDebugOff
    : T_DEBUG_OFF // all work is in scanner
    ;

DirectiveDebugOn
    : T_DEBUG_ON // all work is in scanner
    ;

DirectiveDoubleGroup
    : DirectiveDoubleGroupType CompileDoubleExpressionList
    {
        // now append each number from list
        for (Token* token : *$2)
        {
            SectionHandlerUnit::AppendFloatingPointValue($1, token);
        }
    }
    ;

DirectiveDoubleGroupType
    : T_DOUBLE
    {
        $$ = 64;
    }
    | T_FLOAT
    {
        $$ = 32;
    }
    | T_SINGLE
    {
        $$ = 32;
    }
    ;

DirectiveEndm
    : T_ENDM
    {
        TokenHandlerUnit::EndMacro();
    }
    ;

DirectiveEquGroup
    : DirectiveEquGroupType Identifier T_DELIM Expression
    {
        // redefine symbol if it was already defined
        SymbolHandlerUnit::DefineSet($2->StrAttr(), $4);
    }
    ;

DirectiveEquGroupType
    : T_EQU
    | T_SET
    ;

DirectiveEquivGroup
    : DirectiveEquivGroupType Identifier T_DELIM Expression
    {
        SymbolHandlerUnit::DefineEquiv($2->StrAttr(), $4);
        delete $2;
        delete $4;
    }
    ;

// all variants currently behave the same way
DirectiveEquivGroupType
    : T_EQUIV
    | T_EQV
    ;

DirectiveErr
    : T_ERR
    {
        err::DIRECTIVE_ERROR(LogicalFileInfo::GetLocation(true), DEFAULT_DIRECTIVE_ERR_MESSAGE);
    }
    ;

DirectiveError
    : T_ERROR
    {
        err::DIRECTIVE_ERROR(LogicalFileInfo::GetLocation(), DEFAULT_DIRECTIVE_ERROR_MESSAGE);
    }
    | T_ERROR String
    {
        err::DIRECTIVE_ERROR(LogicalFileInfo::GetLocation(true), $2->StrAttr());
        delete $2;
    }
    ;

DirectiveFile
    : T_FILE IntegerConstantValue String
    {
        g_DwarfLineInfo.AddFileInfo($2, $3->StrAttr());
        delete $3;
    }
    | T_FILE String
    {
        // ignored
        delete $2;
    }
    ;

DirectiveFill
    : T_FILL CompileExpressionValue
    {
        SectionHandlerUnit::AppendBytesRepeat(1, 0, $2);
    }
    | T_FILL CompileExpressionValue T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::AppendBytesRepeat($4, 0, $2);
    }
    | T_FILL CompileExpressionValue T_DELIM CompileExpressionValue T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::AppendBytesRepeat($4, $6, $2);
    }
    ;

// The .global directive. Creates new symbol or modifies existing to be defined as global.
DirectiveGlobalGroup
    : DirectiveGlobalGroupType DirectiveGlobalGroupSymbols
    ;

DirectiveGlobalGroupType
    : T_GLOBAL
    | T_GLOBL
    ;

DirectiveGlobalGroupSymbols
    : DirectiveGlobalGroupSymbol
    | DirectiveGlobalGroupSymbols T_DELIM DirectiveGlobalGroupSymbol
    ;

DirectiveGlobalGroupSymbol
    : Identifier
    {
        SymbolHandlerUnit::SetSymbolVisibility($1->StrAttr(), true);
        delete $1;
    }
    ;

DirectiveIdent
    : T_IDENT String
    {
        SectionHandlerUnit::AppendIdent($2->StrAttr());
        delete $2;
    }
    ;

DirectiveIncbin
    : T_INCBIN String
    {
        SectionHandlerUnit::AppendDataIncBin($2->StrAttr(), 0, false, 0);
    }
    | T_INCBIN String T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::AppendDataIncBin($2->StrAttr(), $4, false, 0);
    }
    | T_INCBIN String T_DELIM CompileExpressionValue T_DELIM CompileExpressionValue
    {
        SectionHandlerUnit::AppendDataIncBin($2->StrAttr(), $4, true, $6);
    }
    ;

// ignored, deprecated
DirectiveLine
    : T_LINE CompileExpressionValue
    ;

DirectiveList
    : T_LIST
    {
        g_SyntAnalyzer.instrCoder.IncrementListingCounter();
    }
    ;

DirectiveLoc
    : T_LOC IntegerConstantValue IntegerConstantValue MaybeDirectiveLocColumn MaybeDirectiveLocOptions
    {
        g_DwarfLineInfo.AddLocInfo($2, $3, $4, *$5);
        delete $5;
    }
    ;

MaybeDirectiveLocColumn
    : // empty
    {
        $$ = 0;
    }
    | IntegerConstantValue
    {
        $$ = $1;
    }
    ;

MaybeDirectiveLocOptions
    // basic_block, prologue_end, epilogue_begin
    : Identifier MaybeDirectiveLocOptions
    {
        $$ = $2;
    
        if ($1->StrAttr() == "basic_block")
        {
            $$->SetBasicBlock(true);
        }
        else if ($1->StrAttr() == "prologue_end")
        {
            $$->SetPrologueEnd(true);
        }
        else if ($1->StrAttr() == "epilogue_begin")
        {
            $$->SetEpilogueBegin(true);
        }
        else
        {
            //wrn::IGNORE_LOC_OPTION(LogicalFileInfo::GetLocation(true), $1->StrAttr());
        }

        delete $1;
    }
    // is_stmt N, isa N, discriminator N
    | Identifier IntegerConstantValue MaybeDirectiveLocOptions
    {
        $$ = $3;

        if ($1->StrAttr() == "discriminator")
        {
            $$->SetDiscriminator($2);
        }
        else
        {
            //wrn::IGNORE_LOC_OPTION(LogicalFileInfo::GetLocation(true), $1->StrAttr());
        }

        delete $1;
    }
    | // empty
    {
        $$ = new LocOptions();
    }
    ;

DirectiveLocal
    : T_LOCAL Identifier
    {
        SymbolHandlerUnit::SetSymbolVisibility($2->StrAttr(), false);
        delete $2;
    }
    ;

DirectiveMacro
    : T_MACRO Identifier DirectiveMacroArguments
    {
        Macro::Arguments arguments;
        for (Token* token : *$3)
        {
            arguments.push_back(token->StrAttr());
        }
        TokenHandlerUnit::StartMacro($2->StrAttr(), arguments);
        delete $2;
        delete $3;
    }
    ;

DirectiveMacroArguments
    : // empty
    {
        $$ = new TokenList;
    }
    | DirectiveMacroArguments Identifier
    {
        $$ = $1;
        $$->push_back($2);
    }
    ;

DirectiveNoaltmacro
    : T_NOALTMACRO
    {
        TokenHandlerUnit::SetAlternateMacroMode(false);
    }
    ;

DirectiveNolist
    : T_NOLIST
    {
        g_SyntAnalyzer.instrCoder.DecrementListingCounter();
    }
    ;

DirectiveOrg
    : T_ORG CompileExpression MaybeFill
    {
        SectionHandlerUnit::SetOrg($2->ToInteger(), $3);
        delete $2;
    }
    ;

DirectivePopsection
    : T_POPSECTION
    {
        SectionHandlerUnit::PopSection();
    }
    ;

DirectivePrevious
    : T_PREVIOUS
    {
        SectionHandlerUnit::Previous();
    }
    ;

DirectiveProfiler
    : T_PROFILER String
    {
        DirectiveHandlerUnit::ProfilerInfo($2->StrAttr());
    }
    | T_PROFILER String T_DELIM String
    {
        DirectiveHandlerUnit::ProfilerInfo($2->StrAttr(), $4->StrAttr());
    }
    ;

DirectivePushsection
    : T_PUSHSECTION SectionName SectionFlags
    {
        SectionHandlerUnit::PushSection(*$2, *$3);
        delete $2;
        delete $3;
    }
    ;

DirectiveSection
    : DirectiveSectionKeyword SectionName SectionFlags
    {
        SectionHandlerUnit::CreateSection(*$2, *$3);
        delete $2;
        delete $3;
    }
    ;

DirectiveSectionKeyword
    : T_SECTION
    {
        SectionHandlerUnit::SetSectionProcessed(true);
    }
    ;

DirectiveSectionAdjustable
    : DirectiveSectionAdjustableKeyword SectionName T_DELIM String T_DELIM CompileExpressionValue T_DELIM CompileExpressionValue T_DELIM DirectiveSectionAdjustableEndianess
    {
        // .section_adjustable name, flags, word bitwidth, byte bitwidth, endianess (.little|.big)
        const string sectionName = *$2;
        const string& flags = $4->StrAttr();
        AsmSection::Type type = AsmSection::TEXT;
        int wordSize = $6;
        int byteSize = $8;
        bool isLittle = ($10 == T_ENDIAN_LITTLE);

        if (byteSize == 0 || wordSize == 0 || wordSize % byteSize != 0)
        {
            err::SECTION_DIVISIBLE_WORD_SIZE_BY_BYTE_SIZE(LogicalFileInfo::GetLocation(true),
                sectionName, wordSize, byteSize);
        }

        type = SectionHandlerUnit::ParseCoffSectionTypeFlags(flags, "");

        SectionHandlerUnit::CreateOrSwitchToSection(type, sectionName, true, wordSize,
            wordSize / byteSize, isLittle);
    }
    ;

DirectiveSectionAdjustableKeyword
    : T_SECTION_ADJUSTABLE
    {
        SectionHandlerUnit::SetSectionProcessed(true);
    }
    ;

DirectiveSectionAdjustableEndianess
    : T_ENDIAN_LITTLE   { $$ = T_ENDIAN_LITTLE; }
    | T_ENDIAN_BIG      { $$ = T_ENDIAN_BIG; }
    ;

DirectiveSize
    : T_SIZE Identifier T_DELIM Expression
    {
        SymbolHandlerUnit::SetSymbolSize($2->StrAttr(), *$4);
        delete $2;
        delete $4;
    }
    ;

DirectiveSkipGroup
    : DirectiveSkipGroupType CompileExpressionValue MaybeFill
    {
        SectionHandlerUnit::AppendBytesRepeat(1, $3, $2);
    }
    ;

DirectiveSkipGroupType
    : T_SKIP
    | T_SPACE
    | T_ZERO
    ;

DirectiveSleb128Group
    : DirectiveSleb128GroupType ExpressionList
    {
        bool isSigned = $1;

        // store each value
        for (Token* token : *$2)
        {
            CHECK_CONDITION(token->Id() == T_NUM_CONST || token->Id() == T_SYMBOL);
            AsmSymbol::ValueType valueType;
            exprval_t value = token->NumAttrEval(&valueType);

            if (valueType != AsmSymbol::ABSOLUTE)
            {
                err::ULEB128_SLEB128_NOT_A_CONSTANT(LogicalFileInfo::GetLocation());
                break;
            }

            vector<char> bytes;
            bytes = LongLongToLebBytes(isSigned, value);

            for (size_t k = 0; k < bytes.size(); k++)
            {
                // byte size compatibility is checked when adding a byte to the target section
                SectionHandlerUnit::AppendDataBitWidth(8, bytes[k]);
            }
        }
    }
    ;

// returns whether leb number is signed
DirectiveSleb128GroupType
    : T_SLEB128 { $$ = true; }
    | T_ULEB128 { $$ = false; }
    ;

DirectiveType
    : T_TYPE Identifier T_DELIM Identifier DirectiveTypeDescription
    {
        // address space prefix is ignored
        SymbolHandlerUnit::SetSymbolUsageType($2->StrAttr(), $4->StrAttr());
        delete $2;
        delete $4;
    }
    ;

DirectiveTypeDescription
    : T_DELIM Identifier
    {
        wrn::IGNORE_TYPE_DIRECTIVE_SPECIFIER(LogicalFileInfo::GetLocation(true), $2->StrAttr());
        delete $2;
    }
    | // empty
    ;

DirectiveWarning
    : T_WARNING
    {
        wrn::DIRECTIVE_WARNING(LogicalFileInfo::GetLocation(), DEFAULT_DIRECTIVE_WARNING_MESSAGE);
    }
    | T_WARNING String
    {
        wrn::DIRECTIVE_WARNING(LogicalFileInfo::GetLocation(true), $2->StrAttr());
        delete $2;
    }
    ;

DirectiveWeak
    : T_WEAK Identifier
    {
        SymbolHandlerUnit::SetSymbolVisibility($2->StrAttr(), true, true);
        delete $2;
    }
    ;

MaybeFill
    : T_DELIM CompileExpressionValue
    {
        $$ = $2;
    }
    |
    {
        $$ = 0;
    }
    ;

SectionName
    : Identifier
    {
        $$ = new string($1->StrAttr());
        delete $1;
    }
    | String
    {
        $$ = new string($1->StrAttr());
        delete $1;
    }
    | T_DATA
    {
        $$ = new string(".data");
    }
    
    | T_TEXT
    {
        $$ = new string(".text");
    }
    | T_BSS
    {
        $$ = new string(".bss");
    }
    | Identifier T_OP_MINUS Identifier
    {
        // create section name from these two ids
        $$ = new string($1->StrAttr() + "-" + $3->StrAttr());
        delete $1;
        delete $3;
    }
    ;

// [, "flags"[, @type[,flag_specific_arguments]]]
SectionFlags
    : // empty
    {
        $$ = new SectionFlags();
    }
    | T_DELIM String SectionType
    {
        $$ = $3;
        $$->SetFlags($2->StrAttr());
        delete $2;
    }
    ;

// [, @type[,flag_specific_arguments]]]
SectionType
    : // empty
    {
        $$ = new SectionFlags();
    }
    | T_DELIM SectionTypeSpecifier SectionFlagSpecificArguments
    {
        $$ = $3;
        $$->SetType($2->StrAttr());
        delete $2;
    }
    ;

SectionTypeSpecifier
    : Identifier
    {
        SectionTypeDescription type = SectionTypeDescription::FromStr($1->StrAttr());
        if (type == SECTION_TYPE_INVALID)
        {
            wrn::UNEXPECTED_SECTION_TYPE_ARGUMENT(LogicalFileInfo::GetLocation(), $1->StrAttr());
        }
        $$ = $1;
    }
    ;

// [,flag_specific_arguments]]]
SectionFlagSpecificArguments
    : // empty
    {
        $$ = new SectionFlags();
    }
    | T_DELIM IntegerConstantValue
    {
        // ignore
        $$ = new SectionFlags();
    }
    | T_DELIM IdOrString T_DELIM Identifier
    {
        // ignore
        $$ = new SectionFlags();
        delete $2;
        delete $4;
    }
    | T_DELIM CompileExpressionValue T_DELIM IdOrString T_DELIM Identifier
    {
        // ignore
        $$ = new SectionFlags();
        delete $4;
        delete $6;
    }
    ;

Label
    : Identifier T_LABEL_DELIM
    {
        SymbolHandlerUnit::DefineLabel($1->StrAttr());
        delete $1;
    }
    | DecimalConstant T_LABEL_DELIM
    {
        SymbolHandlerUnit::DefineLocalLabel($1->IntAttr());
        delete $1;
    }
    ;

MacroCall
    : T_MACRO_CALL MaybeMacroCallArguments
    {
        TokenHandlerUnit::CallMacro(*$1, *$2);
        delete $1;
        delete $2;
    }
    ;

MaybeMacroCallArguments
    : // empty
    {
        $$ = new TokenList;
    }
    | MacroCallArguments
    {
        $$ = $1;
    }
    ;

MacroCallArguments
    : MacroCallArgument
    {
        $$ = new TokenList;
        $$->push_back($1);
    }
    | MacroCallArguments T_DELIM MacroCallArgument
    {
        $$ = $1;
        $$->push_back($3);
    }
    ;

// FIXME, our macro does not allow string concatenation by macro ...
MacroCallArgument
    : Identifier
    {
        $$ = $1;
    }
    | T_PAR_LEFT Identifier T_PAR_RIGHT
    {
        $$ = $2;
    }
    ;

SymbolDefinition
    : Identifier SymbolDefinitionOperator Expression
    {
        SymbolHandlerUnit::DefineSymbol($1->StrAttr(), $2, $3);
        delete $1;
        delete $3;
    }
    ;

// // FIXME add support for all the assignments. Problem is: Symbol 'X' is defined recursively.
SymbolDefinitionOperator
    : T_ASSIGN      { $$ = ASSIGN; }
    ;
    /*| T_AND_ASSIGN  { $$ = AND_ASSIGN; }
    | T_ADD_ASSIGN  { $$ = ADD_ASSIGN; }
    | T_SUB_ASSIGN  { $$ = SUB_ASSIGN; }
    | T_MUL_ASSIGN  { $$ = MUL_ASSIGN; }
    | T_DIV_ASSIGN  { $$ = DIV_ASSIGN; }
    */

CompileDoubleExpressionList
    : // empty
    {
        TokenList* tokens = new TokenList;
        $$ = tokens;
    }
    | DoubleConstant
    {
        // create new token list and append this constant value as token
        $$ = new TokenList;
        $$->push_back($1);
    }
    | CompileExpression
    {
        // create new token list and append this constant value as token
        $$ = new TokenList;
        $$->push_back($1);
    }
    | CompileDoubleExpressionList T_DELIM DoubleConstant
    {
        // append new token to already existing token list
        $$ = $1;
        $$->push_back($3);
    }
    | CompileDoubleExpressionList T_DELIM CompileExpression
    {
        // append new token to already existing token list
        $$ = $1;
        $$->push_back($3);
    }
    ;

CompileExpressionList
    : CompileExpression
    {
        // create new token list and append this constant value as token
        $$ = new TokenList;
        $$->push_back($1);
    }
    | CompileExpressionList T_DELIM CompileExpression
    {
        // append new token to already existing token list
        $$ = $1;
        $$->push_back($3);
    }
    ;

ExpressionList
    : Expression
    {
        // create new token list and append this constant value as token
        $$ = new TokenList;
        $$->push_back($1);
    }
    | ExpressionList T_DELIM Expression
    {
        // append new token to already existing token list
        $$ = $1;
        $$->push_back($3);
    }
    ;

StringList
    : String
    {
        $$ = new TokenList;
        $$->push_back($1);
    }
    | StringList T_DELIM String
    {
        $$ = $1;
        $$->push_back($3);
    }
    ;

CompileExpressionValue
    : CompileExpression
    {
        $$ = $1->IntAttr();
        delete $1;
    }
    ;

// This rule is defined because in some cases we need to have expressions that must be
// evaluated during first pass of compilation right when they are encountered.
// Example can be the .section directive: '.section' name ',' word bit-width ',' flags
// Here, the word bit-width must be known immediately.
// Returns Token* that has id T_NUM_CONST.
CompileExpression
    : Expression
    {
        Token* token = (Token*)$1;
        
        // is this expression represented by a pseudo-symbol? (could not be evaluated in compile-time?)
        if (token->Id() == T_SYMBOL)
        {
            // just a check - symbol expression evaluation result value type must not be absolute 
            AsmSymbol::ValueType valueType;
            const exprval_t value = token->NumAttrEval(&valueType);

            if (valueType == AsmSymbol::SECTION_RELATIVE)
            {
                $$ = &Token::CreateNumerical(value);
            }
            else
            {
                err::NOT_COMPILE_TIME_EXPRESSION(LogicalFileInfo::GetLocation(),
                token->SymbolAttr()->GetName());

                // and now we need to create something instead of this symbol that can be sent as left 
                // nonterminal attribute
                delete token;
                $$ = &Token::CreateNumerical(1);
            }
        }
        else
        {
            $$ = $1;
        }
        
        CHECK_CONDITION($$->Id() == T_NUM_CONST);
    }
    ;

// Main expression nonterminal. Uses expression handler unit to evaluate expression AST
// to a numerical value or to create pseudo symbol that represents this expression.
// Returns Token* that can have id either T_SYMBOL or T_NUM_CONST.
Expression
    : ExpressionAll
    {
        $$ = &g_SyntAnalyzer.exprHandler.HandleExpr(*$1);
        delete $1;
    }
    ;

// Simple expression used for situations where usage of full expression may be ambiguous
// If not used, bison may print a warning (TODO: can be the warning removed?)
SimpleExpression
    : ExpressionCore
    {
        $$ = &g_SyntAnalyzer.exprHandler.HandleExpr(*$1);
        delete $1;
    }
    ;

// Returns TokenNode*.
ExpressionAll
    : ExpressionAll T_OP_BIN_OR ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_BIN_OR , $1, $3);
    }
    | ExpressionAll T_OP_BIN_XOR ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_BIN_XOR, $1, $3);
    }
    | ExpressionAll T_OP_BIN_AND ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_BIN_AND, $1, $3);
    }
    | ExpressionAll T_OP_LSHIFT ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_LSHIFT, $1, $3);
    }
    | ExpressionAll T_OP_RSHIFT ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_RSHIFT, $1, $3);
    }
    | ExpressionAll T_OP_PLUS ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_PLUS, $1, $3);
    }
    | ExpressionAll T_OP_MINUS ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_MINUS, $1, $3);
    }
    | ExpressionAll T_OP_MULT ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_MULT, $1, $3);
    }
    | ExpressionAll T_OP_DIV ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_DIV, $1, $3);
    }
    | ExpressionAll T_OP_MOD ExpressionAll
    {
        $$ = TokenNode::CreateBinary(T_OP_MOD, $1, $3);
    }
    | T_OP_NEG ExpressionAll
    {
        $$ = TokenNode::CreateUnary(T_OP_NEG, $2);
    }
    | T_OP_BIN_NEG ExpressionAll
    {
        $$ = TokenNode::CreateUnary(T_OP_BIN_NEG, $2);
    }
    | T_OP_PLUS ExpressionAll %prec UPLUS
    {
        $$ = TokenNode::CreateUnary(T_OP_PLUS, $2);
    }
    | T_OP_MINUS ExpressionAll %prec UMINUS
    {
        $$ = TokenNode::CreateUnary(T_OP_MINUS, $2);
    }
    | ExpressionCore
    {
        $$ = $1;
    }
    ;

// Expressions: parentheses, constants, identifiers and function calls.
ExpressionCore
    : IntegerConstant
    {
        $$ = TokenNode::CreateLeaf(*$1);
    }
    | Identifier
    {
        $$ = TokenNode::CreateLeaf(*$1);
    }
    | T_PAR_LEFT ExpressionAll T_PAR_RIGHT
    {
        $$ = $2;
    }
    ;

IdOrString
    : String
    {
        $$ = $1;
    }
    | Identifier
    {
        $$ = $1;
    }
    ;

// Simple rule that transforms read ID to token structure.
// Returns Token*.
Identifier
    : T_ID
    {
        string name = *$1;

        // remove leading dots
        if (g_AsmOptions.GetRemoveTwoDotsFromId())
        {
            if (name.size() >= 2 && name[0] == '.' && name[1] == '.')
            {
                name = name.substr(1);
            }
        }

        $$ = &Token::CreateId(name);
        delete $1;
    }
    | T_DOT
    {
        string labelName = "@current_address_" + codasip::IntToStr(LogicalFileInfo::GetLine());
        SymbolHandlerUnit::DefineLabel(labelName);

        $$ = &Token::CreateId(labelName);
    }
    ;

// Simple rule that transforms read string to token structure.
// Value of attribute of this nonterminal is a token with string attribute.
String
    : T_STRING
    {
        // we need to remove string quotes
        $$ = &Token::CreateString($1->substr(1, $1->size() - 2));
        delete $1;
    }
    ;

IntegerConstantValue
    : IntegerConstant
    {
        $$ = $1->IntAttr();
        delete $1;
    }

// Nonterminal IntegerConstant represents constant number used in assembler source file.
// Returns Token*.
IntegerConstant
    : BinaryConstant
    {
        $$ = $1;
    }
    | OctalConstant
    {
        $$ = $1;
    }
    | DecimalConstant
    {
        $$ = $1;
    }
    | HexadecimalConstant
    {
        $$ = $1;
    }
    ;

BinaryConstant
    : T_BIN_CONST
    {
        $$ = &TokenHandlerUnit::ConvertConstantToToken(*$1, 2, 2, "binary");
        delete $1;
    }
    ;

OctalConstant
    : T_OCT_CONST
    {
        $$ = &TokenHandlerUnit::ConvertConstantToToken(*$1, 1, 8, "octal");
        delete $1;
    }
    ;

DecimalConstant
    : T_DEC_CONST
    {
        $$ = &TokenHandlerUnit::ConvertConstantToToken(*$1, 0, 10, "decimal");
        delete $1;
    }
    ;

HexadecimalConstant
    : T_HEX_CONST
    {
        $$ = &TokenHandlerUnit::ConvertConstantToToken(*$1, 2, 16, "hexadecimal");
        delete $1;
    }
    ;

DoubleConstant
    : MaybeMinus T_DOUBLE_CONST
    {
        char* stopstr;

        errno = 0;
        double value = strtod($2->c_str(), &stopstr);
        int err = errno;

        if (*stopstr != 0 || err != 0)
        {
            err::DOUBLE_CONSTANT_CONVERSION(LogicalFileInfo::GetLocation(true), *$2, err);
        }

        if ($1)
        {
            value = -value;
        }

        $$ = &Token::CreateDouble(value);
        
        delete $2;
    }
    ;

MaybeMinus
    : /* empty */   { $$ = false; }
    | T_OP_MINUS    { $$ = true; }
    ;

// Used mainly for VLIW architectures to be able to skip comments inside a bundle.
// Represents at least one newline.
MaybeNewlines
    : T_NEWLINE
    | MaybeNewlines T_NEWLINE
    ;


%%



/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*---------------------------------- end of user-modifiable section ------------------------------*/
/*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*/

/**
 *  \brief This function is called when syntactic error was encountered.
 */
void yyerror(const char* s)
{
    std::string msg;
    TokenIdInfos::ReplaceTokenNames(msg, s);
    err::SYNTACTIC_ANALYSIS_ERROR(LogicalFileInfo::GetLocation(true), msg);
}
