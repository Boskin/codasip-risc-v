/**
 * Codasip Ltd
 *
 * CONFIDENTIAL
 *
 * Copyright 2014 Codasip Ltd
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of Codasip Ltd
 * and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip Ltd and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 */
 
/**
 *  \brief Base of lexical analyzer for assembly code generated by msp-gcc compiler.
 * 
 *         Instruction set information is generated automatically,
 *         this file describes mainly directives and label and constants formats.
 *
 *         Lexical analyzer generated from this file can have 2 different modes:
 *         1. - ASM_LEX_ANALYZER - serves as fixed part of lexical analyzer for assembler.
 *         2. - ASM_INSTR_TOKEN_RECOGNIZER - used to recognize tokens (terminals)
 *                                           retrieved from instruction set description.
 *
 *         Mode 1 is set default.
 *         To override it and to set to mode, compile c file generated from this lex file
 *         with defined macro ASM_INSTR_TOKEN_RECOGNIZER (-DASM_INSTR_TOKEN_RECOGNIZER).
 *  \note Support for .local directive in conjunction with .comm, now is ignored
 */

%option nostdinit
%option nounput
%option noyywrap
%option yylineno
%array  // we may modify yytext
/* %option interactive */
%option case-insensitive

%{
#ifdef _WIN32
#define YY_NO_UNISTD_H
#include <io.h>
#endif

#include <string>

#include "check_condition.h"
#include "codasip_io.h"

#include "asmstdinclude.h"


extern int yydebug;


/* mode selection */
#ifndef ASM_INSTR_TOKEN_RECOGNIZER
#define ASM_LEX_ANALYZER
#endif


#ifdef ASM_LEX_ANALYZER

#ifndef YYTOKENTYPE

#include <string>
#include <inttypes.h>

#include "assembler_messages.h"
#include "directivehandleriface.h"
#include "logical_file_info.h"


namespace codasip {
namespace assembler {
class Token;
class TokenList;
class TokenNode;
}
}


#define RETURN(X) { \
    bool isMacroCall; \
    int token = TokenHandlerUnit::Process(isMacroCall, yylval.text, X); \
    if (isMacroCall) \
    { \
        BEGIN(IN_MACRO_CALL); \
    } \
    return token; \
}


// YYTOKENTYPE is defined in merged_scanner_gen.hpp
#include "merged_parser_gen.hpp"

#endif  // YYTOKENTYPE


#include <map>
#include <vector>


// yylex function override because of concatenated terminal handling
#define YY_DECL int orig_yylex()


#elif defined ASM_INSTR_TOKEN_RECOGNIZER

#include <string>
#include <inttypes.h>


class Token;
class TokenList;
class TokenNode;


int yydebug;    // not linked with syntactic analyzer


#define RETURN(X) { return (X); }


#include "tokeninfo_gen.hpp"


YYSTYPE yylval;


/**
 *  \brief This value is returned in case that input token is the same as (collides) character
 *         that begins an one-line comment.
 */
#define T_COMMENT_ERROR 0x7FFFFFFD

/**
 *  \brief Unknown token value - this value is returned by the recognizer in case that
 *         input token was not recognized.
 */
#define T_UNKNOWN 0x7FFFFFFE

/** 
 *  \brief Erroneous token recognized - that means a token that is general and cannot be used
 *         as a string or a number. Tokens for which recognizer returns this value collide
 *         with assembler and expression grammar definitions.
 */
#define T_TOKEN_ERROR 0x7FFFFFFF

/**
 *  \brief Overridden input method.
 *         GetNextInput returns false, when there is no another text to read
 *         - in this case we need to return EOB_ACT_END_OF_FILE directly
 *         from function yy_get_next_buffer(), where is this macro used.
 *         (see this generated function yy_get_next_buffer())
 */
/* FIXME hack: Compatible with flex >= 2.5.36 */
void GetNextInput(char* buf, yy_size_t* resultSize, int maxSize);
/* FIXME hack: Compatible with flex <= 2.5.35 */
void GetNextInput(char* buf, int* resultSize, int maxSize);
#define YY_INPUT(buf, result, maxSize) \
    GetNextInput((buf), &(result), (maxSize))


#endif  // ASM_INSTR_TOKEN_RECOGNIZER


using namespace codasip::assembler;


%}


 /* these defines must not be modified, they are used in generated code */
D       [0-9]
L       [\$a-zA-Z_\.]
LNDOT   [\$a-zA-Z_]
LM      [\$a-zA-Z_\.\-]
H       [a-fA-F0-9]
B       [01]
O       [0-7]

DEC     [\+\-]?{D}+
HEX     "0x"{H}+
ID      [@]?({LNDOT}|"."{LNDOT})({L}|{D})*
IDM     {LM}({LM}|{D})*
NUM     ({DEC}|{HEX})
SEXPR   ({NUM}|{ID})
STRING  "\""[^\"]+"\""
WS      [ \t]*
WS1     [ \t]+

IDENTIFIER {ID}|{NUM}("b"|"f")


 /*-----------------------------------------------------------------------------------------------*/
 /*-----------------------------------------------------------------------------------------------*/
 /*--------------------------------------start of user-modifiable section-------------------------*/
 /*-----------------------------------------------------------------------------------------------*/
 /*-----------------------------------------------------------------------------------------------*/

%{

// some unnecessary directives are ignored, however some may
// be important and using this macro, you can turn on or off warnings about these directives
#define PRINT_WARNING_ON_NONSUPPORTED_DIRECTIVES

void WarnNotSupportedDirective(const char* name);
void Ignoring(IgnoreType type = IGNORE_NONE);

%}


%x IN_C_COMMENT
%x IN_MACRO_CALL


%%



 /* comments */
"//"[^\n]* {
    #if defined ASM_LEX_ANALYZER
    #elif defined ASM_INSTR_TOKEN_RECOGNIZER
        return T_COMMENT_ERROR;
    #endif
}

"/*" {
    #if defined ASM_LEX_ANALYZER
        BEGIN (IN_C_COMMENT);
    #elif defined ASM_INSTR_TOKEN_RECOGNIZER
        return T_COMMENT_ERROR;
    #endif
}

<IN_C_COMMENT>
{
"*/"    BEGIN(INITIAL);
[^*\n]+ /* nothing */
"*"     /* nothing */
\n {
#if defined ASM_LEX_ANALYZER
    LogicalFileInfo::IncrementLine();
    yylval.num = yylineno; // line information
#endif
}
<<EOF>> {
#if defined ASM_LEX_ANALYZER
    codasip::assembler::err::UNEXPECTED_EOF_INSIDE_COMMENT(LogicalFileInfo::GetLocation(true));
#endif
    THROW_ERROR();
}
}

<IN_MACRO_CALL>
{
{IDENTIFIER} {
    yylval.text = new std::string(yytext);
    return T_ID;
}
\n {
#if defined ASM_LEX_ANALYZER
    LogicalFileInfo::IncrementLine();
    yylval.num = yylineno; // line information
#endif
    BEGIN(INITIAL);
    return T_NEWLINE;
}
}

 /* lines from preprocessor */
^[ \t]*("#line "|"# "){D}+" \""[^\"]+"\""[ ]?({D}[ ]?)*"\n" {
#if defined ASM_LEX_ANALYZER
    //"# num filename flags" - line directive generated by C preprocessor,
    // flags are ignored
    // used code from codal compiler
    // see http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html
    errno = 0;
    int ii = 0;
    // skip whitespaces
    while (yytext[ii] != '#') {++ii;}
    // skip not decimal digits (MSVC #line)
    while (!isdigit(yytext[ii])) {++ii;}
    
    // parse line number
    int line = strtol(yytext + ii, NULL, 10);

    CHECK_CONDITION(errno == 0)
        << "Error while converting preprocessor-generated line number." << std::endl;

    // skip line number
    while (yytext[ii++] != '\"') {}
    // copy full path
    int jj = 0;
    char file[512];
    while (yytext[ii] != '\"') { file[jj++] = yytext[ii++]; CHECK_CONDITION(jj < 511); }
    file[jj] = '\0';
    // store line info
    yylineno = line;
    // set given file path and line
    LogicalFileInfo::SetFileName(fs::Path(file));
    LogicalFileInfo::SetLine(line);

#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_TOKEN_ERROR);
#endif
}

 /* ignored directives */
".arch"{WS1}{ID}                            Ignoring();
".cfi_lsda"{WS1}{NUM}","{WS1}{ID}           Ignoring(codasip::assembler::IGNORE_CFI);
".cfi_personality"{WS1}{NUM}","{WS1}{ID}    Ignoring(codasip::assembler::IGNORE_CFI);
".cfi_sections"{WS1}{ID}                    Ignoring();
".cfi_signal_frame"                         Ignoring();
".cpload"{WS1}"$"{NUM}                      Ignoring();
".cprestore"{WS1}{NUM}                      Ignoring();
".endfunc"                                  Ignoring();
".ent"{WS1}{ID}                             Ignoring();
".ent"{WS1}{ID}","{NUM}                     Ignoring();
".extern"{WS1}{ID}                          Ignoring();
".fmask"{WS1}{NUM}{WS}","{WS}{NUM}          Ignoring();
".func"{WS1}{ID}                            Ignoring();
".gnu_attribute"{WS1}{NUM}{WS}","{WS}{NUM}  Ignoring();
".hidden"{WS1}{ID}                          Ignoring();
".lflags"{WS1}{ID}                          Ignoring();
".mask"{WS1}{NUM}                           Ignoring();
".mask"{WS1}{NUM}{WS}","{WS}{NUM}           Ignoring();

 /* For RISC-V */
".option"{WS1}{ID}                          Ignoring();

".proc"{WS1}{ID}                            Ignoring();

 /* unsupported directives */
 /* note: some of the patterns for directives arguments may be wrong */
".abort"                                WarnNotSupportedDirective(yytext);
".desc"{WS1}{ID}{WS}","{WS}{SEXPR}      WarnNotSupportedDirective(yytext);
".end"                                  WarnNotSupportedDirective(yytext);
".end"{WS1}{ID}                         WarnNotSupportedDirective(yytext);
".entry"                                WarnNotSupportedDirective(yytext);
".fail"{WS1}{SEXPR}                     WarnNotSupportedDirective(yytext);
".include"{WS1}{STRING}                 WarnNotSupportedDirective(yytext);
".linkonce"                             WarnNotSupportedDirective(yytext);
".octa"{WS1}{NUM}                       WarnNotSupportedDirective(yytext);
".reloc"{WS1}{NUM}{WS}","{WS}{ID}{WS}   WarnNotSupportedDirective(yytext);
".string"{WS1}{STRING}                  WarnNotSupportedDirective(yytext);
".string8"{WS1}{STRING}                 WarnNotSupportedDirective(yytext);
".string16"{WS1}{STRING}                WarnNotSupportedDirective(yytext);
".string32"{WS1}{STRING}                WarnNotSupportedDirective(yytext);
".string64"{WS1}{STRING}                WarnNotSupportedDirective(yytext);
".subsection"                           WarnNotSupportedDirective(yytext);

 /* erroneous directives */
".usect" {
#if defined ASM_LEX_ANALYZER
    err::UNSUPPORTED_DIRECTIVE_USECT(LogicalFileInfo::GetLocation(true));
    throw AssemblerError();
#endif
}

 /* directive tokens */
".abs_org"          RETURN(T_ABS_ORG);
".address_space"    RETURN(T_ADDRESS_SPACE);

".align"    RETURN(T_ALIGN);
".balign"   RETURN(T_BALIGN);
".balignw"  RETURN(T_BALIGNW);
".balignl"  RETURN(T_BALIGNL);
".p2align"  RETURN(T_P2ALIGN);
".p2alignw" RETURN(T_P2ALIGNW);
".p2alignl" RETURN(T_P2ALIGNL);

".altmacro" RETURN(T_ALTMACRO);
".ascii"    RETURN(T_ASCII);
".asciz"    RETURN(T_ASCIZ);
".bit"              RETURN(T_BIT);
".bundle_align_end" RETURN(T_BUNDLE_ALIGN_END);

".byte"     RETURN(T_BYTE);
".hword"    RETURN(T_HWORD);
".int"      RETURN(T_INT);
".long"     RETURN(T_LONG);
".quad"     RETURN(T_QUAD);
".short"    RETURN(T_SHORT);
".word"     RETURN(T_WORD);
".half"     RETURN(T_HALF);
".dword"    RETURN(T_DWORD);
".2byte"    RETURN(T_2BYTE);
".4byte"    RETURN(T_4BYTE);

".cfi_startproc"            RETURN(T_CFI_STARTPROC);
".cfi_endproc"              RETURN(T_CFI_ENDPROC);
".cfi_def_cfa"              RETURN(T_CFI_DEF_CFA);
".cfi_def_cfa_register"     RETURN(T_CFI_DEF_CFA_REGISTER);
".cfi_def_cfa_offset"       RETURN(T_CFI_DEF_CFA_OFFSET);
".cfi_adjust_cfa_offset"    RETURN(T_CFI_ADJUST_CFA_OFFSET);
".cfi_offset"               RETURN(T_CFI_OFFSET);
".cfi_val_offset"           RETURN(T_CFI_VAL_OFFSET);
".cfi_register"             RETURN(T_CFI_REGISTER);
".cfi_same_value"           RETURN(T_CFI_SAME_VALUE);
".cfi_return_column"        RETURN(T_CFI_RETURN_COLUMN);

".codasip_retstruct_reg"    RETURN(T_CODASIP_RETSTRUCT_REG);
".codasip_retval_regs"      RETURN(T_CODASIP_RETVAL_REGS);

".comm"     RETURN(T_COMM);
".lcomm"    RETURN(T_LCOMM);

".data"     RETURN(T_DATA);
".text"     RETURN(T_TEXT);
".bss"      RETURN(T_BSS);

".debug_off"    { yydebug = 0; RETURN(T_DEBUG_OFF); }
".debug_on"     { yydebug = 1; RETURN(T_DEBUG_ON); }

".double"   RETURN(T_DOUBLE);
".float"    RETURN(T_FLOAT);
".single"   RETURN(T_SINGLE);

".endm"     RETURN(T_ENDM);

".equ"      RETURN(T_EQU);
".set"      RETURN(T_SET);
".equiv"    RETURN(T_EQUIV);
".eqv"      RETURN(T_EQV);

".err"      RETURN(T_ERR);
".error"    RETURN(T_ERROR);

".file"         RETURN(T_FILE);
".fill"         RETURN(T_FILL);
".global"       RETURN(T_GLOBAL);
".globl"        RETURN(T_GLOBL);
".ident"        RETURN(T_IDENT);
".incbin"       RETURN(T_INCBIN);
".line"         RETURN(T_LINE);
".list"         RETURN(T_LIST);
".loc"          RETURN(T_LOC);
".local"        RETURN(T_LOCAL);
".macro"        RETURN(T_MACRO);
".noaltmacro"   RETURN(T_NOALTMACRO);
".nolist"       RETURN(T_NOLIST);
".org"          RETURN(T_ORG);

".popsection"           RETURN(T_POPSECTION);
".previous"             RETURN(T_PREVIOUS);
".profiler"             RETURN(T_PROFILER);
".pushsection"          RETURN(T_PUSHSECTION);
".section"              RETURN(T_SECTION);
".section_adjustable"   RETURN(T_SECTION_ADJUSTABLE);

".big"      RETURN(T_ENDIAN_BIG);
".little"   RETURN(T_ENDIAN_LITTLE);

".size"     RETURN(T_SIZE);
".skip"     RETURN(T_SKIP);
".space"    RETURN(T_SPACE);
".zero"     RETURN(T_ZERO);
".sleb128"  RETURN(T_SLEB128);
".uleb128"  RETURN(T_ULEB128);
".type"     RETURN(T_TYPE);
".warning"  RETURN(T_WARNING);
".weak"     RETURN(T_WEAK);

 /* single characters */
"."     RETURN(T_DOT);
":"     RETURN(T_LABEL_DELIM);

 /* symbol definition operators */
 /*"&="    RETURN(T_AND_ASSIGN);
"+="    RETURN(T_ADD_ASSIGN);
"-="    RETURN(T_SUB_ASSIGN);
"*="    RETURN(T_MUL_ASSIGN);
"/="    RETURN(T_DIV_ASSIGN);*/
"="     RETURN(T_ASSIGN);

 /* arithmetic operators */
"!"     RETURN(T_OP_NEG);
"~"     RETURN(T_OP_BIN_NEG);

"*"     RETURN(T_OP_MULT);
"/"     RETURN(T_OP_DIV);
"%"     RETURN(T_OP_MOD);
"+"     RETURN(T_OP_PLUS);
"-"     RETURN(T_OP_MINUS);
"<<"    RETURN(T_OP_LSHIFT);
">>"    RETURN(T_OP_RSHIFT);
"&"     RETURN(T_OP_BIN_AND);
"^"     RETURN(T_OP_BIN_XOR);
"|"     RETURN(T_OP_BIN_OR);

"\n" {
#if defined ASM_LEX_ANALYZER
    LogicalFileInfo::IncrementLine();
    yylval.num = yylineno; // line information
#endif
    RETURN(T_NEWLINE);
}

 /* some quite general tokens */

 /* binary constant */
0[bB]{B}+ {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_BIN_CONST);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_BIN_CONST); /* not allowed collision */
#endif
}

 /* octal constant */
0{O}+ {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_OCT_CONST);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_OCT_CONST); /* not allowed collision */
#endif
}

 /* decimal constant */
{D}+ {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_DEC_CONST);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_DEC_CONST); /* not allowed collision */
#endif
}

 /* hexadecimal constant */
0[xX]{H}+ {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_HEX_CONST);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_HEX_CONST); /* not allowed collision */
#endif
}

 /* float constant */
[0-9]+\.?[0-9]+([eE][-+]?[0-9]+)? {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_DOUBLE_CONST);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_DOUBLE_CONST); /* not allowed collision */
#endif
}

 /* string literal */
\"("\\\""|"\\\\"|"\\a"|"\\b"|"\\t"|"\\f"|"\\n"|"\\r"|"\\'"|"\\x"{H}|"\\"{D}|[^\"\\])*\" {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    RETURN(T_STRING);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_TOKEN_ERROR); /* not allowed collision */
#endif
}

 /* identifier, local labels start with numbers */
{IDENTIFIER} {
#if defined ASM_LEX_ANALYZER
    yylval.text = new std::string(yytext);
    int res = TokenHandlerUnit::MatchIdToken(*yylval.text, T_ID);
    if (res != T_ID)
    {
        delete yylval.text;
        yylval.text = NULL;
    }
    RETURN(res);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    // T_ID is not used when generating terminals,
    // but this information is also important for assembler generator
    // (see SymbolNameAssigner::AssignTerminalGenerationNames)
    RETURN(T_ID); 
#endif
}

 /* evaluation of macro argument */
"\\"{IDENTIFIER} {
    yylval.text = new std::string(yytext);
    RETURN(T_MACRO_ARGUMENT_EVALUATOR);
}

<<EOF>> {
#if defined ASM_LEX_ANALYZER
    TokenHandlerUnit::AddCurrentToken(TokenInfo::CreateEof());
    yylval.num = -1;
    RETURN(T_NEWLINE);
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_UNKNOWN);
#endif
}

<INITIAL,IN_MACRO_CALL>
{
","     RETURN(T_DELIM);

"("     RETURN(T_PAR_LEFT);
")"     RETURN(T_PAR_RIGHT);

 /* eat-up whitespace */
[ \t]

. {
#if defined ASM_LEX_ANALYZER
    // special handling of windows files on linux
    if (*yytext !=  0xD)
    {
        err::UNEXPECTED_CHARACTER(LogicalFileInfo::GetLocation(true), yytext, *yytext);
    }
#elif defined ASM_INSTR_TOKEN_RECOGNIZER
    RETURN(T_UNKNOWN);
#endif
}
}


%%



#if defined ASM_LEX_ANALYZER

void WarnNotSupportedDirective(const char* name)
{
#ifdef PRINT_WARNING_ON_NONSUPPORTED_DIRECTIVES
    wrn::UNSUPPORTED_DIRECTIVE(LogicalFileInfo::GetLocation(true), name);
#endif  // PRINT_WARNING_ON_NONSUPPORTED_DIRECTIVES
}

void Ignoring(IgnoreType type)
{
    static bool msg_printed_cfi = false;

    // print just one message for each type
    if (type == IGNORE_CFI && !msg_printed_cfi)
    {
        wrn::IGNORE_DIRECTIVE(LogicalFileInfo::GetLocation(true));
        msg_printed_cfi = true;
    }
}

#elif defined ASM_INSTR_TOKEN_RECOGNIZER

void WarnNotSupportedDirective(const char*)
{}

void Ignoring(IgnoreType)
{}

#endif


 /*-----------------------------------------------------------------------------------------------*/
 /*-----------------------------------------------------------------------------------------------*/
 /*---------------------------------------end of user-modifiable section--------------------------*/
 /*-----------------------------------------------------------------------------------------------*/
 /*-----------------------------------------------------------------------------------------------*/


#if defined ASM_LEX_ANALYZER


// Function that sets scanners input file.
// Must be called beforwe bison generated parser is started by
// yyparse function.
// @param fin Input file, must be opened for reading.
void SetInputFile(FILE* fin)
{
    yyin = fin;
}

int Terminate()
{
    yyterminate();
}

/// overridden yylex function because of concatenated terminal handling
int yylex()
{
    return TokenHandlerUnit::GetCurrentToken();
}


#elif defined ASM_INSTR_TOKEN_RECOGNIZER


// Global variable used as input string, its size and current position.
const char* g_Input;
int g_InputSize;
int g_CurrentPosition;

/**
 *  \brief Is used by macro YY_INPUT. Because we need to know whether whole input string was matched,
 *         function returns only one by one character.
 *         FIXME hack: 2nd argument compatible with flex >= 2.5.36
 *  \param buf is a buffer of size maxSize, is not zero-terminated,
 *             into resultSize is saved number of characters copied into buf
 *  \param resultSize
 *  \param maxSize
 *  \return false, when there is no another text to read.
 */
void GetNextInput(char* buf, yy_size_t* resultSize, int maxSize)
{
    CHECK_NOT_NULL(buf);
    CHECK_NOT_NULL(resultSize);
    CHECK_CONDITION(maxSize >= 1);

    if (g_CurrentPosition != g_InputSize)
    {
        buf[0] = g_Input[g_CurrentPosition];
        *resultSize = 1;
        g_CurrentPosition++;
    }
    else
    {
        *resultSize = YY_NULL;
    }
}

/**
 *  \brief FIXME hack: 2nd argument compatible with flex <= 2.5.35
 */
void GetNextInput(char* buf, int* resultSize, int maxSize)
{
    yy_size_t tempResultSize;
    GetNextInput(buf, &tempResultSize, maxSize);
    *resultSize = tempResultSize;
}

/**
 *  \brief This method is used to recognize input strings, returns token numbers or T_UNKNOWN.
 */
int Recognize(const char* s)
{
    CHECK_NOT_NULL(s);

    // restart our recognizer
    // WARNING: yyrestart() does not reset the start condition to INITIAL
    yyrestart(NULL);

    // set input string and current posision
    g_Input = s;
    g_InputSize = strlen(s);
    g_CurrentPosition = 0;

    // let generated scanner recognize input string
    int res = yylex();

    // string must be matched completely, otherwise it was not recognized
    if (strcmp(yytext, s) == 0)
    {
        return res;
    }
    else
    {
        return T_UNKNOWN;
    }
}


#endif  // ASM_INSTR_TOKEN_RECOGNIZER
