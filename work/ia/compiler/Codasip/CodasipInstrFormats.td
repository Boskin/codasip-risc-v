/**
 * Codasip Ltd
 *
 * CONFIDENTIAL
 *
 * Copyright 2017 Codasip Ltd
 *
 * All Rights Reserved.
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 * \file
 * \date    2017-11-25
 * \author  Codasip (c) C compiler backend generator
 * \version 6.8.2-1.win.7.EVALUATION
 * \brief   Source for compiler backend
 * \project RISC_V5.ia
 * \note          6.8.2-1.win.7.EVALUATION\n      Licensee: C51_657_727\n      Project: RISC_V5.ia\n      Date: 2017-11-25 23:37:30\n      Copyright (C) 2017 Codasip Ltd.
 */


// Definition of symbols used by CodasipInstrInfo.

/// Basic Codasip instruction.
class CodasipInst<dag outs, dag ins>: Instruction
{
  let Namespace = "Codasip";
  let OutOperandList = outs;
  let InOperandList = ins;
  // Predicate info
  string PredSense = "";
  let TSFlags{2} = !if(!eq(PredSense, "false"),1,0);
  bits<1> isPredicated = 0;
  let TSFlags{1} = isPredicated;
  string BaseOpcode = "";
  bits<1> isPredicable = 0;
  bits<1> allowInDelaySlot = 1;
  let TSFlags{3} = allowInDelaySlot;
}

include "CodasipMicroClasses.td"

/** Node representing a general call used for all targets generated by Codesip.
 * Note: SDTBrind is used - don't let the name fool you, we simply require pointer type */
def Call: SDNode<"CodasipISD::Call", SDTBrind, [SDNPHasChain,SDNPOptInGlue,SDNPOutGlue,SDNPVariadic]>;
// tail call
def TailCall: SDNode<"CodasipISD::TailCall", SDTBrind, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;

/// Node representing a general return used for all targets generated by Codesip.
def Return: SDNode<"CodasipISD::Ret", SDTNone, [SDNPHasChain,SDNPOptInGlue,SDNPVariadic]>;
/// Target of a jump (for input operands specification)
def brtarg: Operand<OtherVT>;
/// Wrapper of global symbols
def GAWrap: SDNode<"CodasipISD::GAWrap", SDTIntUnaryOp, []>;
/// Checks names of global symbols
class GAWrapC<int w, int s, int t>: PatFrag<(ops node:$ptr), (GAWrap node:$ptr), "return CheckSymbol(N,"#w#","#s#","#t#");">;
// extended imm operands (pattern nodes)
class immExt<ValueType vt, int w, int s, int t>:
ImmLeaf<vt, "return CheckImm(Imm,"#w#","#s#","#t#");">;
def GAWrap_Trunc12_i32: GAWrapC<32,0,12>;
def Trunc12_i32imm: immExt<i32,32,0,12>;
def GAWrap_sext12To32: GAWrapC<12,1,0>;
def sext12To32imm: immExt<i32,12,1,0>;
def GAWrap_zext5To32: GAWrapC<5,0,0>;
def zext5To32imm: immExt<i32,5,0,0>;


// operands with custom predicates


// definitions for indexed load, see SDTIStore
def SDTILoad: SDTypeProfile<2, 2, [
  SDTCisSameAs<0,1>, SDTCisPtrTy<0>, SDTCisPtrTy<3>
]>;
def ild:   SDNode<"ISD::LOAD", SDTILoad, [SDNPHasChain, SDNPMayLoad, SDNPMemOperand]>;

def iload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::NON_EXTLOAD;
}]>;
def iextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::EXTLOAD;
}]>;
def isextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::SEXTLOAD;
}]>;
def izextload: PatFrag<(ops node:$base, node:$offset), (ild node:$base, node:$offset), [{
  return cast<LoadSDNode>(N)->getExtensionType() == ISD::ZEXTLOAD;
}]>;

// our own indexed load and store
def pre_inc_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC;
}]>;
def post_inc_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC;
}]>;
def pre_dec_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC;
}]>;
def post_dec_load: PatFrag<(ops node:$base, node:$offset), (iload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC;
}]>;

def pre_inc_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC;
}]>;
def post_inc_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC;
}]>;
def pre_dec_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC;
}]>;
def post_dec_store: PatFrag<(ops node:$val, node:$base, node:$offset), (istore node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC;
}]>;

// custom extloads and truncstores


// combinations of indexed extloads/truncstores

def pre_inc_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_extloadi8: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_sextloadi8: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_zextloadi8: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_inc_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def pre_dec_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;
def post_dec_truncstorei8: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i8;
}]>;

def pre_inc_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_extloadi16: PatFrag<(ops node:$base, node:$offset), (iextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_sextloadi16: PatFrag<(ops node:$base, node:$offset), (isextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_zextloadi16: PatFrag<(ops node:$base, node:$offset), (izextload node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<LoadSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;

def pre_inc_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_inc_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_INC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def pre_dec_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::PRE_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;
def post_dec_truncstorei16: PatFrag<(ops node:$val, node:$base, node:$offset), (ist node:$val, node:$base, node:$offset), [{
  return cast<LSBaseSDNode>(N)->getAddressingMode() == ISD::POST_DEC  &&  cast<StoreSDNode>(N)->getMemoryVT() == MVT::i16;
}]>;


// loads and stores with various alignments and for various types
class CodasipLoadStore<dag ops, dag frag, int a, int s>:
PatFrag<ops,frag, "return CheckLoadStore(cast<MemSDNode>(N),"#a#","#s#");">;
def extloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (extloadi16 node:$ptr), 1, 0>;
def extloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (extloadi8 node:$ptr), 1, 0>;
def load_a1_s0: CodasipLoadStore<(ops node:$ptr), (load node:$ptr), 1, 0>;
def sextloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (sextloadi16 node:$ptr), 1, 0>;
def sextloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (sextloadi8 node:$ptr), 1, 0>;
def zextloadi16_a1_s0: CodasipLoadStore<(ops node:$ptr), (zextloadi16 node:$ptr), 1, 0>;
def zextloadi8_a1_s0: CodasipLoadStore<(ops node:$ptr), (zextloadi8 node:$ptr), 1, 0>;
def store_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (store node:$val, node:$ptr), 1, 0>;
def truncstorei16_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (truncstorei16 node:$val, node:$ptr), 1, 0>;
def truncstorei8_a1_s0: CodasipLoadStore<(ops node:$val, node:$ptr), (truncstorei8 node:$val, node:$ptr), 1, 0>;


// FI inhibitors for tied register operands
// (and fixed regs can't be used to eat FI - would cause "node emitted late" assert)
def NotFI_rf_xpr_0: PatLeaf<(iAny rf_xpr_0:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_1: PatLeaf<(iAny rf_xpr_1:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_2: PatLeaf<(iAny rf_xpr_2:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_3: PatLeaf<(iAny rf_xpr_3:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_4: PatLeaf<(iAny rf_xpr_4:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_5: PatLeaf<(iAny rf_xpr_5:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_6: PatLeaf<(iAny rf_xpr_6:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_7: PatLeaf<(iAny rf_xpr_7:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_8: PatLeaf<(iAny rf_xpr_8:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_9: PatLeaf<(iAny rf_xpr_9:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_10: PatLeaf<(iAny rf_xpr_10:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_11: PatLeaf<(iAny rf_xpr_11:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_12: PatLeaf<(iAny rf_xpr_12:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_13: PatLeaf<(iAny rf_xpr_13:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_14: PatLeaf<(iAny rf_xpr_14:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_15: PatLeaf<(iAny rf_xpr_15:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_16: PatLeaf<(iAny rf_xpr_16:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_17: PatLeaf<(iAny rf_xpr_17:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_18: PatLeaf<(iAny rf_xpr_18:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_19: PatLeaf<(iAny rf_xpr_19:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_20: PatLeaf<(iAny rf_xpr_20:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_21: PatLeaf<(iAny rf_xpr_21:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_22: PatLeaf<(iAny rf_xpr_22:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_23: PatLeaf<(iAny rf_xpr_23:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_24: PatLeaf<(iAny rf_xpr_24:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_25: PatLeaf<(iAny rf_xpr_25:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_26: PatLeaf<(iAny rf_xpr_26:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_27: PatLeaf<(iAny rf_xpr_27:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_28: PatLeaf<(iAny rf_xpr_28:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_29: PatLeaf<(iAny rf_xpr_29:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_30: PatLeaf<(iAny rf_xpr_30:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_rf_xpr_31: PatLeaf<(iAny rf_xpr_31:$r), "return !FrameIndexSDNode::classof(N);">;
def NotFI_xpr: PatLeaf<(iAny xpr:$r), "return !FrameIndexSDNode::classof(N);">;
def CheckFI_xpr: PatLeaf<(iAny xpr:$r), "return CheckFI(N, Codasip::xprRegClassID);">;


// vector shuffles


